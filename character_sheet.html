<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RPG Character Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>
  <script src="supabase.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #23272a;
      color: #fff;
      margin: 0;
      padding: 0;
    }
    html, body {
      height: 100%;
      width: 100%;
      margin: 0;
      padding: 0;
    }
    body {
      min-height: 100vh;
      min-width: 100vw;
      box-sizing: border-box;
    }
    .dashboard {
      width: 100vw;
      min-height: 100vh;
      margin: 0;
      background: #2c2f33;
      border-radius: 0;
      box-shadow: none;
      padding: 32px 2vw 32px 2vw;
      display: flex;
      flex-direction: column;
      gap: 32px;
      box-sizing: border-box;
    }
    .top-row {
      display: flex;
      flex-direction: row;
      gap: 32px;
      width: 100%;
      flex: 0 0 auto;
      min-height: 0;
    }
    .profile, .stats {
      flex: 1 1 0;
      min-width: 0;
      min-height: 0;
      display: flex;
      flex-direction: column;
      max-width: 48%;
    }
    .bottom-row {
      flex: 0 0 auto;
      min-height: 0;
      display: flex;
      flex-direction: column;
      gap: 24px;
      width: 100%;
      margin-top: 32px;
    }
    .profile {
      text-align: center;
      background: #23272a;
      padding: 24px 24px 18px 24px;
      border-radius: 16px;
      box-sizing: border-box;
      min-height: 400px;
    }
    .stats {
      background: #23272a;
      padding: 24px 24px 18px 24px;
      border-radius: 16px;
      box-sizing: border-box;
      min-height: 400px;
    }
    .stats table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .stats th, .stats td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #444;
    }
    .stats th:first-child { width: 30%; }
    .stats th:nth-child(2) { width: 20%; }
    .stats th:nth-child(3) { width: 50%; }
    .profile img {
      width: 120px;
      border-radius: 50%;
      border: 4px solid #7289da;
      margin-bottom: 16px;
    }
    .profile h2 {
      margin: 0;
      font-size: 2em;
      color: #7289da;
    }
    .inventory, .abilities {
      margin-bottom: 24px;
      text-align: left;
      background: #23272a;
      padding: 24px 24px 18px 24px;
      border-radius: 16px;
      box-sizing: border-box;
      overflow: visible;
      width: 100%;
    }
    .add-remove {
      background: #23272a;
      padding: 18px 24px 18px 24px;
      border-radius: 16px;
      width: 100%;
      margin: 0 0 24px 0;
      box-sizing: border-box;
    }
    .section-title {
      font-size: 1.2em;
      color: #43b581;
      margin-bottom: 8px;
      border-bottom: 2px solid #43b581;
      display: inline-block;
      padding-bottom: 2px;
    }
    .inventory ul, .abilities ul {
      list-style: none;
      padding: 0;
    }
    .inventory li, .abilities li {
      background: #23272a;
      margin-bottom: 6px;
      padding: 8px;
      border-radius: 6px;
      border-left: 4px solid #7289da;
    }
    /* Tooltip styles */
    .tooltip {
      position: absolute;
      background: #23272a;
      color: #fff;
      border: 1px solid #7289da;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 0.95em;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      max-width: 320px;
      display: none;
    }
    /* responsive stack on small screens */
    @media (max-width: 900px) {
      .top-row { flex-direction: column; }
      .profile, .stats { max-width: 100%; }
      .dashboard { padding: 16px; }
    }
  </style>
</head>
<body>
  <div class="dashboard">
    <div class="top-row">
      <div class="profile">
  <img id="avatar-img" src="https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar_.jpg" alt="Character Avatar" onerror="handleAvatarError(this)">
    <script>
    function handleAvatarError(img) {
      // Try local fallback first
      if (!img.src.includes('avatar.jpg')) {
        img.onerror = function() {
          // Try Supabase default avatar
          img.onerror = function() {
            // If all fail, show blank and set title
            img.onerror = null;
            img.src = '';
            img.title = 'No avatar image found.';
          };
          img.src = 'https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar.jpg';
          img.title = 'Avatar could not be loaded. Showing default avatar.';
        };
        img.src = 'avatar.jpg';
        img.title = 'Avatar could not be loaded. Trying local fallback.';
      }
    }
    </script>
        <input type="file" id="avatar-upload" accept="image/png, image/jpeg" style="margin-top:10px;">
        <div id="avatar-fallback" style="display:none;margin-top:10px;padding:8px;border-radius:6px;background:#2b2f33;color:#ffd166;">
          <div style="margin-bottom:6px;"><strong>Avatar upload failed because the storage bucket appears to be missing.</strong></div>
          <div style="font-size:0.95em;margin-bottom:8px;color:#ddd;">You can either create a storage bucket named <code>avatars</code> in your Supabase project (Storage → Create bucket → public), or provide a direct image URL below to use as the avatar.</div>
          <input id="avatar-url-input" type="url" placeholder="https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar.jpg" style="width:68%;padding:6px;border-radius:4px;border:1px solid #444;background:#111;color:#fff;" />
          <button id="avatar-url-save" style="padding:6px 10px;margin-left:8px;">Use Image URL</button>
        </div>
        <h2 id="char-name"></h2>
        <p id="char-class"></p>
        <div id="char-summary" style="margin-top:10px;color:#43b581;font-size:1em;"></div>
        <div id="char-bio" style="margin-top:18px;padding:10px;background:#23272a;border-radius:8px;color:#b9bbbe;font-size:1em;white-space:pre-line;"></div>
        <div style="margin-top:18px;">
          <label for="bio-edit" style="color:#43b581;font-size:1em;">Bio / Notes:</label>
          <textarea id="bio-edit" rows="3" style="width:100%;margin-top:4px;border-radius:4px;padding:8px;background:#23272a;color:#b9bbbe;font-size:1em;"></textarea>
          <button id="save-bio-btn" style="margin-top:6px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;">Save Bio</button>
        </div>
        <button id="printSheetBtn" style="margin-top:18px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;">Print Character Sheet</button>
        <!-- Avatar removed: file not found -->
      </div>
      <div class="stats">
        <div class="section-title">Stats</div>
        <table id="stats-table"></table>
      </div>
    </div>
    <div class="bottom-row">
      <div class="add-remove">
        <div class="section-title">Add/Remove</div>
        <form id="addForm" style="margin-bottom:24px;display:flex;flex-wrap:nowrap;align-items:center;gap:8px;">
          <label for="type" style="margin:0 4px 0 0;">Type:</label>
          <select id="type" name="type" style="flex:0 0 20%;max-width:100px;max-width:40%;">
            <option value="items">Item</option>
            <option value="equipment">Equipment</option>
            <option value="skills">Skill</option>
            <option value="spells">Spell</option>
            <option value="xp">XP</option>
          </select>
          <label for="suggestion">Name:</label>
          <input type="text" id="suggestion" name="suggestion" list="suggestions" autocomplete="off" required>
          <span id="suggestion-cost" style="margin-left:8px;color:#faa61a;white-space:nowrap;"></span>
          <datalist id="suggestions"></datalist>
          <label for="count" style="margin:0 4px 0 0;">Count:</label>
          <input type="number" id="count" name="count" min="1" value="1" required style="width:3ch;min-width:40px;max-width:48px;text-align:center;">
          <button type="submit" style="background: #43b581;">Add</button>
          <button type="button" id="removeBtn" style="background: #f04747; margin-left: 2px;">Remove</button>
        </form>
      </div>
      <div class="inventory">
        <div class="section-title" style="text-align:left;">Weapons</div>
        <div id="weapons-list" style="margin-bottom:16px;min-height:24px;"></div>
        <div class="section-title">Armor</div>
        <div id="armors-list" style="margin-bottom:16px;min-height:24px;"></div>
        <div class="section-title">Items</div>
        <div id="items-list" style="margin-bottom:16px;min-height:24px;"></div>
      </div>
      <div class="abilities">
        <div class="section-title" style="text-align:left;">Skills</div>
        <table id="skills-table" style="width:100%;margin-bottom:12px;"></table>
        <div class="section-title">Spells</div>
        <table id="spells-table" style="width:100%;margin-bottom:12px;"></table>
      </div>
    </div>
  </div>
  <div id="sheet-data" style="margin:32px 0;"></div>
  <div id="tooltip" class="tooltip"></div>
  <script>
    // Bio edit/save logic
    document.addEventListener('DOMContentLoaded', function() {
      const bioEdit = document.getElementById('bio-edit');
      const saveBioBtn = document.getElementById('save-bio-btn');
      if (saveBioBtn && bioEdit) {
        saveBioBtn.addEventListener('click', async function() {
          if (!currentCharacter || !currentUsername) return;
          const newBio = bioEdit.value.trim();
          await updateCharacter(currentUsername, { bio: newBio });
          currentCharacter.bio = newBio;
          document.getElementById('char-bio').textContent = newBio || 'The tale of this adventurer is yet to be written...';
          alert('Bio updated!');
        });
      }
    });
    // Avatar upload logic
    document.addEventListener('DOMContentLoaded', function() {
      const avatarInput = document.getElementById('avatar-upload');
      const fallback = document.getElementById('avatar-fallback');
      if (avatarInput) {
        avatarInput.addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) return;
          if (file.type !== 'image/jpeg') {
            alert('Only JPEG images (.jpg) are allowed.');
            return;
          }
          if (file.size > 200*1024) {
            alert('Image must be under 200KB.');
            return;
          }
          // Resize image to max 256x256px
          const img = new Image();
          img.onload = async function() {
            const canvas = document.createElement('canvas');
            const maxDim = 256;
            let w = img.width, h = img.height;
            if (w > maxDim || h > maxDim) {
              if (w > h) {
                h = Math.round(h * (maxDim / w));
                w = maxDim;
              } else {
                w = Math.round(w * (maxDim / h));
                h = maxDim;
              }
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            canvas.toBlob(async function(blob) {
              // Always use .jpg and canonical name
              const fileName = `avatar_${currentUsername}.jpg`;
              try {
                // Always use upsert:true to replace old avatar
                const { data, error } = await supabaseClient.storage.from('avatars').upload(fileName, blob, {
                  upsert: true,
                  contentType: 'image/jpeg'
                });
                if (error) throw error;
                // Always use canonical public URL
                const publicURL = `https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar_${currentUsername}.jpg`;
                // Save URL to character, but handle missing avatar_url column gracefully
                let res = null;
                let avatarUrlUpdateFailed = false;
                try {
                  res = await updateCharacter(currentUsername, { avatar_url: publicURL });
                } catch (err) {
                  // If error is about missing avatar_url column, retry without it
                  if (err && err.message && err.message.toLowerCase().includes("avatar_url")) {
                    avatarUrlUpdateFailed = true;
                    try {
                      res = await updateCharacter(currentUsername, {});
                    } catch (e2) {
                      // fallback: still update UI
                      res = currentCharacter;
                    }
                  } else {
                    throw err;
                  }
                }
                if (!res) {
                  alert('Avatar uploaded but saving to character failed. Check console for details.');
                  return;
                }
                currentCharacter = res;
                // Force reload image to avoid browser cache
                const avatarImg = document.getElementById('avatar-img');
                if (avatarImg) {
                  avatarImg.src = publicURL + '?t=' + Date.now();
                }
                if (avatarUrlUpdateFailed) {
                  alert("Avatar uploaded, but your database does not have an 'avatar_url' column. The image will show, but the URL is not saved in the database. (Ask your admin to add the column if you want this feature.)");
                } else {
                  alert('Avatar updated!');
                }
              } catch (err) {
                console.error('Avatar upload error:', err);
                // If the bucket isn't found, show fallback UI with instructions
                const fallback = document.getElementById('avatar-fallback');
                if (err && err.message && err.message.toLowerCase().includes('bucket')) {
                  fallback.style.display = 'block';
                  alert('Avatar upload failed: storage bucket not found. See fallback instructions.');
                } else {
                  // generic error show message and fallback
                  fallback.style.display = 'block';
                  alert('Avatar upload failed: ' + (err.message || err));
                }
              }
            }, 'image/jpeg', 0.92);
          };
          const reader = new FileReader();
          reader.onload = function(ev) { img.src = ev.target.result; };
          reader.readAsDataURL(file);
        });
      }
    });
  // Suggestions infrastructure
    // Print Character Sheet logic
    document.addEventListener('DOMContentLoaded', function() {
      const printBtn = document.getElementById('printSheetBtn');
      if (printBtn) {
        printBtn.addEventListener('click', function() {
          if (currentCharacter) openPrintableCharacterSheet(currentCharacter);
        });
      }
    });

    function openPrintableCharacterSheet(character) {
      const printWindow = window.open('', '_blank', 'width=800,height=1000,scrollbars=yes');
      // Stat bonus logic
      const raceInfo = {
        "Human": { bonus: { strength: 1, dexterity: 1, constitution: 1 } },
        "Elf": { bonus: { dexterity: 2, intelligence: 1 } },
        "Dwarf": { bonus: { constitution: 2, strength: 1 } },
        "Halfling": { bonus: { dexterity: 2, charisma: 1 } },
        "Dragonborn": { bonus: { strength: 2, charisma: 1 } },
        "Gnome": { bonus: { intelligence: 2, constitution: 1 } },
        "Half-Elf": { bonus: { charisma: 2, dexterity: 1 } },
        "Half-Orc": { bonus: { strength: 2, constitution: 1 } },
        "Tiefling": { bonus: { charisma: 2, intelligence: 1 } }
      };
      const classInfo = {
        "Fighter": { bonus: { strength: 2 } },
        "Rogue": { bonus: { dexterity: 2 } },
        "Wizard": { bonus: { intelligence: 2 } },
        "Cleric": { bonus: { wisdom: 2 } },
        "Barbarian": { bonus: { strength: 1, constitution: 1 } },
        "Bard": { bonus: { charisma: 2 } },
        "Druid": { bonus: { wisdom: 1, constitution: 1 } },
        "Monk": { bonus: { dexterity: 1, wisdom: 1 } },
        "Paladin": { bonus: { strength: 1, charisma: 1 } },
        "Ranger": { bonus: { dexterity: 1, wisdom: 1 } },
        "Sorcerer": { bonus: { charisma: 1, constitution: 1 } },
        "Warlock": { bonus: { charisma: 1, intelligence: 1 } }
      };
      const backgroundInfo = {
        "Acolyte": { bonus: { wisdom: 1 } },
        "Charlatan": { bonus: { charisma: 1 } },
        "Criminal": { bonus: { dexterity: 1 } },
        "Entertainer": { bonus: { charisma: 1 } },
        "Folk Hero": { bonus: { constitution: 1 } },
        "Guild Artisan": { bonus: { intelligence: 1 } },
        "Hermit": { bonus: { wisdom: 1 } },
        "Noble": { bonus: { charisma: 1 } },
        "Outlander": { bonus: { constitution: 1 } },
        "Sage": { bonus: { intelligence: 1 } },
        "Sailor": { bonus: { strength: 1 } },
        "Soldier": { bonus: { strength: 1 } },
        "Urchin": { bonus: { dexterity: 1 } }
      };

      function getTotalStat(character, stat) {
        let total = character[stat] || 0;
        if (raceInfo[character.race] && raceInfo[character.race].bonus && raceInfo[character.race].bonus[stat]) {
          total += raceInfo[character.race].bonus[stat];
        }
        if (classInfo[character.class] && classInfo[character.class].bonus && classInfo[character.class].bonus[stat]) {
          total += classInfo[character.class].bonus[stat];
        }
        if (backgroundInfo[character.background] && backgroundInfo[character.background].bonus && backgroundInfo[character.background].bonus[stat]) {
          total += backgroundInfo[character.background].bonus[stat];
        }
        return total;
      }

      // Print skills as a list with bonuses only (no 'Level X')
      function getSkillPrintList(character) {
        const skills = Array.isArray(character.skills) ? character.skills : [];
        let out = [];
        for (const skill of skills) {
          let bonus = 0;
          let sources = [];
          if (character.class && classInfo[character.class] && classInfo[character.class].skill === skill.name) {
            bonus += 2;
            sources.push('Class +2');
          }
          if (character.background && backgroundInfo[character.background] && backgroundInfo[character.background].skills && backgroundInfo[character.background].skills.includes(skill.name)) {
            bonus += 2;
            sources.push('Background +2');
          }
          if ((skill.count ?? 0) > 0 || bonus > 0) {
            let display = skill.name;
            if (sources.length > 0) display += ` (${sources.join(', ')})`;
            out.push(display);
          }
        }
        return out;
      }

      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${character.name || character.username} - Character Sheet</title>
          <style>
            @media print {
              body { margin: 0; }
              .no-print { display: none; }
            }
            body { 
              font-family: 'Times New Roman', serif; 
              margin: 20px; 
              background: white; 
              color: black; 
              line-height: 1.4;
            }
            .header { 
              text-align: center; 
              border-bottom: 3px solid #000; 
              padding-bottom: 10px; 
              margin-bottom: 20px; 
            }
            .character-name { 
              font-size: 28px; 
              font-weight: bold; 
              margin: 0; 
            }
            .character-details { 
              font-size: 16px; 
              margin: 5px 0; 
            }
            .section { 
              margin-bottom: 20px; 
              border: 2px solid #000; 
              padding: 10px; 
            }
            .section-title { 
              font-size: 18px; 
              font-weight: bold; 
              border-bottom: 1px solid #000; 
              margin-bottom: 10px; 
              padding-bottom: 5px; 
            }
            .stats-grid { 
              display: grid; 
              grid-template-columns: repeat(3, 1fr); 
              gap: 10px; 
            }
            .stat-box { 
              border: 1px solid #000; 
              padding: 8px; 
              text-align: center; 
            }
            .stat-name { 
              font-weight: bold; 
              font-size: 12px; 
            }
            .stat-value { 
              font-size: 20px; 
              font-weight: bold; 
            }
            .equipment-list { 
              columns: 2; 
              column-gap: 20px; 
            }
            .equipment-item { 
              break-inside: avoid; 
              margin-bottom: 5px; 
            }
            .no-print { 
              position: fixed; 
              top: 10px; 
              right: 10px; 
            }
            button { 
              padding: 10px 20px; 
              font-size: 16px; 
              cursor: pointer; 
            }
          </style>
        </head>
        <body>
          <button class="no-print" onclick="window.print()">Print Character Sheet</button>
          <div class="header">
            <h1 class="character-name">${character.name || character.username}</h1>
            <div class="character-details">
              Level ${character.level} ${character.race} ${character.class}
            </div>
            <div class="character-details">
              Background: ${character.background} | Username: ${character.username}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Ability Scores</div>
            <div class="stats-grid">
              <div class="stat-box">
                <div class="stat-name">STRENGTH</div>
                <div class="stat-value">${getTotalStat(character, 'strength')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">DEXTERITY</div>
                <div class="stat-value">${getTotalStat(character, 'dexterity')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">CONSTITUTION</div>
                <div class="stat-value">${getTotalStat(character, 'constitution')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">INTELLIGENCE</div>
                <div class="stat-value">${getTotalStat(character, 'intelligence')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">WISDOM</div>
                <div class="stat-value">${getTotalStat(character, 'wisdom')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">CHARISMA</div>
                <div class="stat-value">${getTotalStat(character, 'charisma')}</div>
              </div>
            </div>
          </div>
          <div class="section">
            <div class="section-title">Character Progress</div>
            <p><strong>Level:</strong> ${character.level}</p>
            <p><strong>Experience Points:</strong> ${character.xp || 0}</p>
            <p><strong>XP to Next Level:</strong> ${(100 * (character.level + 1)) - (character.xp || 0)}</p>
            <p><strong>Free Stat Points:</strong> ${character.free_stat_points || 0}</p>
          </div>
          <div class="section">
            <div class="section-title">Equipment & Items</div>
            <div class="equipment-list">
              ${character.equipment ? character.equipment.filter(eq => eq.count > 0).map(eq => 
                `<div class="equipment-item">${eq.name} (${eq.count})</div>`
              ).join('') : '<div>No equipment</div>'}
              ${character.items ? character.items.filter(item => item.count > 0).map(item => 
                `<div class="equipment-item">${item.name} (${item.count})</div>`
              ).join('') : ''}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Skills</div>
            <div class="equipment-list">
              ${getSkillPrintList(character).length > 0 ? getSkillPrintList(character).map(skill => 
                `<div class="equipment-item">${skill}</div>`
              ).join('') : '<div>No skills</div>'}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Spells</div>
            <div class="equipment-list">
              ${character.spells ? character.spells.filter(spell => spell.count > 0).map(spell => 
                `<div class="equipment-item">${spell.name}</div>`
              ).join('') : '<div>No spells</div>'}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Notes</div>
            <div style="height: 150px; border: 1px solid #ccc; padding: 10px;">
              ${character.bio || 'The tale of this adventurer is yet to be written...'}
            </div>
          </div>
        </body>
        </html>
      `);
      printWindow.document.close();
    }
    let sheetSuggestions = { items: [], equipment: [], skills: [], spells: [], xp: ['Experience Points'] };
    let dndData = null;
    async function loadSuggestions() {
      try {
        const res = await fetch('dnd_data.json');
        const data = await res.json();
        dndData = data;
        sheetSuggestions.items = (data.items || []).map(i => i.name);
        sheetSuggestions.equipment = (data.equipment || []).map(e => e.name);
        sheetSuggestions.skills = (data.skills || []).map(s => s.name);
        // Add more suggestion types if needed
      } catch (err) {
        console.error('Failed to load suggestions:', err);
      }
    }
    
    // The following code was misplaced inside loadSuggestions and should be outside as utility/helper/event logic
    
    // Attach manual avatar URL save handler (fallback when storage bucket not available)
    document.addEventListener('DOMContentLoaded', function() {
      const avatarUrlSave = document.getElementById('avatar-url-save');
      const avatarUrlInput = document.getElementById('avatar-url-input');
      const fallback = document.getElementById('avatar-fallback');
      if (avatarUrlSave && avatarUrlInput) {
        avatarUrlSave.addEventListener('click', async function() {
          const url = (avatarUrlInput.value || '').trim();
          if (!url) return alert('Please enter a valid image URL.');
          if (!url.startsWith('http')) return alert('Please enter a valid absolute URL (http/https).');
          if (!currentUsername) return alert('No current user found. Please reload the page while logged in.');
          try {
            const res = await updateCharacter(currentUsername, { avatar_url: url });
            if (!res) return;
            currentCharacter = res;
            const avatarImg = document.getElementById('avatar-img');
            if (avatarImg) avatarImg.src = url;
            if (fallback) fallback.style.display = 'none';
            alert('Avatar URL saved.');
          } catch (err) {
            console.error('Failed to save avatar URL', err);
            alert('Failed to save avatar URL. See console for details.');
          }
        });
      }
      // Proactive check: does the 'avatars' bucket exist? If not, show instructions early
      (async function checkAvatarsBucket() {
        try {
          const listRes = await supabaseClient.storage.from('avatars').list('', { limit: 1 });
          // If bucket doesn't exist supabase-js throws or returns error; if we get here assume ok
          if (listRes && listRes.error) throw listRes.error;
        } catch (err) {
          console.warn('avatars bucket check failed:', err && err.message ? err.message : err);
          if (fallback) fallback.style.display = 'block';
        }
      })();
    });

    // Helper: extract numeric gold cost from dnd entry objects
    function getCostFromEntry(entry) {
      if (!entry) return 0;
      // Common fields
      if (typeof entry.cost === 'number') return entry.cost;
      if (typeof entry.price === 'number') return entry.price;
      const candidates = ['cost','price','value','gp','gold','cost_gp','cost_string'];
      for (const k of candidates) {
        if (entry[k]) {
          const v = entry[k];
          if (typeof v === 'number') return v;
          if (typeof v === 'string') {
            // try to extract number like "10 gp" or "1,000"
            const m = v.replace(/,/g,'').match(/([0-9]+(?:\.[0-9]+)?)/);
            if (m) return parseFloat(m[1]);
          }
        }
      }
      // If entry has a cost object like {quantity:1,unit:'gp'}
      if (entry.cost && typeof entry.cost === 'object') {
        if (entry.cost.quantity) return Number(entry.cost.quantity) || 0;
        if (entry.cost.amount) return Number(entry.cost.amount) || 0;
      }
      return 0;
    }
    document.getElementById('type').addEventListener('change', function() {
      updateSuggestionsList(this.value);
      // If stats selected, show stat keys as suggestions
      if (this.value === 'stats') {
        const datalist = document.getElementById('suggestions');
        datalist.innerHTML = '';
        ['Strength','Dexterity','Constitution','Intelligence','Wisdom','Charisma'].forEach(s => {
          const option = document.createElement('option');
          option.value = s;
          datalist.appendChild(option);
        });
      }
    });
    function updateSuggestionsList(type) {
      const datalist = document.getElementById('suggestions');
      datalist.innerHTML = '';
      sheetSuggestions[type].forEach(s => {
        const option = document.createElement('option');
        option.value = s;
        // if dndData has an entry, attach cost for quick lookup
        try {
          if (dndData && Array.isArray(dndData[type])) {
            const entry = dndData[type].find(x => x.name === s);
            if (entry) option.dataset.cost = String(getCostFromEntry(entry) || '');
          }
        } catch (e) {
          option.dataset.cost = '';
        }
        datalist.appendChild(option);
      });
    }
    // Show cost in the UI when suggestion input changes
    (function attachSuggestionCostListener() {
      const suggestionInput = document.getElementById('suggestion');
      const suggestionCostSpan = document.getElementById('suggestion-cost');
      if (!suggestionInput || !suggestionCostSpan) return;
      suggestionInput.addEventListener('input', function(e) {
        const val = e.target.value;
        let costText = '';
        try {
          const type = document.getElementById('type').value;
          if (dndData && Array.isArray(dndData[type])) {
            const entry = dndData[type].find(x => x.name === val);
            if (entry) {
              const c = getCostFromEntry(entry);
              if (c) costText = `Cost: ${c}G`;
            }
          }
        } catch (err) {
          // ignore
        }
        suggestionCostSpan.textContent = costText;
      });
    })();
    // Manual add logic
    document.getElementById('addForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const type = document.getElementById('type').value;
      const name = document.getElementById('suggestion').value.trim();
      const count = parseInt(document.getElementById('count').value);
      
      if (!name || !count || !currentCharacter || !currentUsername) return;
      
      try {
          // Stat allocation logic
          if (["strength","dexterity","constitution","intelligence","wisdom","charisma"].includes(name.toLowerCase()) && type === 'stats') {
            if ((currentCharacter.free_stat_points ?? 0) < count) {
              alert('Not enough free stat points to allocate.');
              return;
            }
            let statKey = name.toLowerCase();
            let newValue = (currentCharacter[statKey] ?? 0) + count;
            let newPoints = (currentCharacter.free_stat_points ?? 0) - count;
            await updateCharacter(currentUsername, { [statKey]: newValue, free_stat_points: newPoints });
            currentCharacter[statKey] = newValue;
            currentCharacter.free_stat_points = newPoints;
            renderCharacterSheet(currentCharacter);
            return;
          }
        // Update the character data based on type
        if (type === 'items') {
          await addItemToCharacter(name, count);
        } else if (type === 'equipment') {
          await addEquipmentToCharacter(name, count);
        } else if (type === 'skills') {
          await addSkillToCharacter(name, count);
        } else if (type === 'spells') {
          await addSpellToCharacter(name, count);
        } else if (type === 'xp') {
          await addXPToCharacter(count);
        }
        
        // Reset form
        this.reset();
        updateSuggestionsList(document.getElementById('type').value);
      } catch (error) {
        console.error('Error adding item:', error);
        alert('Failed to add item. Please try again.');
      }
    });

    // Remove button logic
    document.getElementById('removeBtn').addEventListener('click', async function(e) {
      e.preventDefault();
      const type = document.getElementById('type').value;
      const name = document.getElementById('suggestion').value.trim();
      const count = parseInt(document.getElementById('count').value);
      
      if (!name || !count || !currentCharacter || !currentUsername) return;
      
      try {
        // Stat point removal logic
        if (["strength","dexterity","constitution","intelligence","wisdom","charisma"].includes(name.toLowerCase()) && type === 'stats') {
          let statKey = name.toLowerCase();
          let currentValue = currentCharacter[statKey] ?? 0;
          if (currentValue < count) {
            alert('Cannot remove more stat points than currently allocated.');
            return;
          }
          let newValue = currentValue - count;
          let newPoints = (currentCharacter.free_stat_points ?? 0) + count;
          await updateCharacter(currentUsername, { [statKey]: newValue, free_stat_points: newPoints });
          currentCharacter[statKey] = newValue;
          currentCharacter.free_stat_points = newPoints;
          renderCharacterSheet(currentCharacter);
          return;
        }
        let items = [];
        if (type === 'items') items = currentCharacter.items || [];
        else if (type === 'equipment') items = currentCharacter.equipment || [];
        else if (type === 'skills') items = currentCharacter.skills || [];
        else if (type === 'spells') items = currentCharacter.spells || [];
        else if (type === 'xp') {
          if ((currentCharacter.xp || 0) === 0) {
            alert(`No XP to remove.`);
            return;
          }
        }
        
        if (type !== 'xp') {
          const existingItem = items.find(item => item.name === name);
          if (!existingItem || (existingItem.count || 0) === 0) {
            alert(`No ${name} to remove.`);
            return;
          }
        }
        
        // Remove from the character data based on type
        if (type === 'items') {
          await removeItemFromCharacter(name, count);
        } else if (type === 'equipment') {
          await removeEquipmentFromCharacter(name, count);
        } else if (type === 'skills') {
          await removeSkillFromCharacter(name, count);
        } else if (type === 'spells') {
          await removeSpellFromCharacter(name, count);
        } else if (type === 'xp') {
          await removeXPFromCharacter(count);
        }
        
        // Reset form
        document.getElementById('addForm').reset();
        updateSuggestionsList(document.getElementById('type').value);
      } catch (error) {
        console.error('Error removing item:', error);
        alert('Failed to remove item. Please try again.');
      }
    });
    async function loadData() {
      // Removed due to CORS issues and not being used
    }
    // setInterval(loadData, 5000);
    // loadData();
  </script>
  <script>
    // Supabase character sheet integration
    let currentUsername = null;
    let currentCharacter = null;
    // Expect username to be passed via localStorage from index.html
    window.addEventListener('DOMContentLoaded', async function() {
      // Try to get username from query string first
      function getQueryParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }
      let username = getQueryParam('username');
      if (!username) {
        username = localStorage.getItem('dnd_username');
      } else {
        localStorage.setItem('dnd_username', username);
      }
      if (username) {
        currentUsername = username;
        const character = await fetchCharacter(username);
        if (character) {
          currentCharacter = character;
          renderCharacterSheet(character);
        }
      } else {
        window.location.href = 'index.html';
      }
    });

    function renderCharacterSheet(character) {
      // Attach chip tooltips for skills/spells
      setTimeout(function() {
        const tooltip = document.getElementById('tooltip');
        function showTooltip(e) {
          if (!e.target.title) return;
          tooltip.textContent = e.target.title;
          tooltip.style.display = 'block';
          tooltip.style.left = (e.pageX + 12) + 'px';
          tooltip.style.top = (e.pageY + 12) + 'px';
        }
        function moveTooltip(e) {
          tooltip.style.left = (e.pageX + 12) + 'px';
          tooltip.style.top = (e.pageY + 12) + 'px';
        }
        function hideTooltip() {
          tooltip.style.display = 'none';
        }
        document.querySelectorAll('.skill-chip, .spell-chip').forEach(chip => {
          chip.addEventListener('mouseenter', showTooltip);
          chip.addEventListener('mousemove', moveTooltip);
          chip.addEventListener('mouseleave', hideTooltip);
        });
      }, 0);
  // Free stat points
  freeStatPoints = character.free_stat_points ?? 0;
  let statPointDiv = document.getElementById('free-stat-points');
  if (!statPointDiv) {
    statPointDiv = document.createElement('div');
    statPointDiv.id = 'free-stat-points';
    statPointDiv.style = 'margin-top:10px;color:#faa61a;font-size:1em;';
    document.querySelector('.profile').appendChild(statPointDiv);
  }
  statPointDiv.textContent = `Free stat points: ${freeStatPoints}`;
  // Gold display
  let goldDiv = document.getElementById('gold-display');
  if (!goldDiv) {
    goldDiv = document.createElement('div');
    goldDiv.id = 'gold-display';
    goldDiv.style = 'margin-top:6px;color:#ffd166;font-size:1em;';
    document.querySelector('.profile').appendChild(goldDiv);
  }
  goldDiv.textContent = `Gold: ${character.gold ?? 0} G`;

  // Status Effects display
  let statusDiv = document.getElementById('status-effects-display');
  if (!statusDiv) {
    statusDiv = document.createElement('div');
    statusDiv.id = 'status-effects-display';
    statusDiv.style = 'margin-top:12px;margin-bottom:4px;';
    document.querySelector('.profile').appendChild(statusDiv);
  }
  // Show status effects as chips with tooltip
  const effects = Array.isArray(character.status_effects) ? character.status_effects : [];
  if (effects.length === 0) {
    statusDiv.innerHTML = `<div id="status-effects-display" style="margin-top: 12px; margin-bottom: 4px;">` + (effects.length === 0
      ? '<span style="color:#888;">No status effects</span>'
      : effects.map(eff => {
          // Find effect in dndData if possible
          let effData = null;
          if (typeof dndData !== 'undefined' && dndData && dndData.status_effects) {
            effData = dndData.status_effects.find(e => e.name === eff.name);
          }
          let desc = effData && effData.desc ? effData.desc : (eff.desc || '');
          let buff = effData && effData.buff ? effData.buff : (eff.buff || '');
          let debuff = effData && effData.debuff ? effData.debuff : (eff.debuff || '');
          let notes = effData && effData.notes ? effData.notes : (eff.notes || '');
          let tooltip = `Status Effect: ${eff.name}`;
          if (desc) tooltip += `\n${desc}`;
          if (buff) tooltip += `\nBuff: ${buff}`;
          if (debuff) tooltip += `\nDebuff: ${debuff}`;
          if (eff.duration) tooltip += `\nDuration: Sustained (DC required)`;
          else tooltip += `\nDuration: Persistent`;
          if (notes) tooltip += `\nNotes: ${notes}`;
          if (effData && effData.condition_type) tooltip += `\nCondition Type: ${effData.condition_type}`;
          if (effData && effData.save_type) tooltip += `\nSave Type: ${effData.save_type}`;
          let sustainedBracket = eff.duration ? ` <span style='color:#faa61a;font-size:0.9em;'>(Sustained - DC required)</span>` : '';
          return `<span class="status-chip" title="${tooltip.replace(/"/g,'&quot;')}">${eff.name}${sustainedBracket}</span>`;
        }).join('')) + `</div>`;
  }
  // Add style for status chips
  (function addStatusChipStyle() {
    if (document.getElementById('status-chip-style')) return;
    const style = document.createElement('style');
    style.id = 'status-chip-style';
    style.textContent = `.status-chip { display:inline-block;background:#444;color:#fff;padding:4px 10px;margin:2px 4px 2px 0;border-radius:8px;font-size:0.98em;cursor:help;transition:background 0.2s; }
    .status-chip:hover { background:#7289da;color:#fff; }`;
    document.head.appendChild(style);
  })();
  // Avatar display
  const avatarImg = document.getElementById('avatar-img');
  if (avatarImg) {
    // Use avatar_url from DB if present, else canonical, else fallback
    let avatarUrl = character.avatar_url;
    if (!avatarUrl) {
      avatarUrl = `https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar_${character.username || character.name || currentUsername}.jpg`;
    }
    avatarImg.onerror = function() {
      // Only fallback if not already on default supabase avatar
      if (!this.src.includes('avatar_.jpg')) {
        this.onerror = function() {
          // If fallback also fails, show blank and set title
          this.onerror = null;
          this.src = '';
          this.title = 'No avatar image found.';
        };
        this.src = 'https://oitwwvjgkmzffsdsodzm.supabase.co/storage/v1/object/public/avatars/avatar.jpg';
        this.title = 'Avatar could not be loaded. Showing default avatar.';
      }
    };
    avatarImg.src = avatarUrl;
    avatarImg.title = character.avatar_url ? '' : 'No avatar set. Upload or provide a URL.';
  }
// Prevent ReferenceError if attachTooltipListeners is missing
if (typeof attachTooltipListeners !== 'function') {
  function attachTooltipListeners() {}
}
  document.getElementById('char-name').textContent = character.name || character.username || '';
  document.getElementById('char-class').textContent = `Level ${character.level ?? ''} ${character.class ?? ''}`;
  // Summary
  let summary = '';
  if (character.race) summary += `<b>Race:</b> ${character.race} `;
  if (character.class) summary += `<b>Class:</b> ${character.class} `;
  if (character.background) summary += `<b>Background:</b> ${character.background}`;
  document.getElementById('char-summary').innerHTML = summary;
  // Bio at bottom of profile
  // Editable bio (show textarea only when "Edit Bio" clicked)
  const bioEdit = document.getElementById('bio-edit');
  const saveBtn = document.getElementById('save-bio-btn');
  if (bioEdit) bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';

  const charBioDiv = document.getElementById('char-bio');
  const storyBioDiv = document.getElementById('story-bio');
  // do not show the separate story-bio container
  if (storyBioDiv) storyBioDiv.style.display = 'none';

  // helper to escape HTML
  function escHtml(s) {
    return (s || '').toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  const mainBioText = character.bio && character.bio.trim() ? character.bio : 'The tale of this adventurer is yet to be written...';
  const storyBioText = character.story_bio && character.story_bio.trim() ? character.story_bio : '';

  // Merge story bio into the same container (do not show separately)
  if (storyBioText) {
    charBioDiv.innerHTML = escHtml(mainBioText).replace(/\n/g, '<br>') +
      `<div style="margin-top:12px;color:#faa61a;white-space:pre-line;"><strong>Story Bio (GM):</strong><br>${escHtml(storyBioText).replace(/\n/g, '<br>')}</div>`;
  } else {
    charBioDiv.innerHTML = escHtml(mainBioText).replace(/\n/g, '<br>');
  }

  // Hide the edit panel by default and show an "Edit Bio" button
  if (bioEdit && saveBtn) {
    const bioContainer = bioEdit.parentElement; // the div that contains label, textarea, and save button
    // create Edit button if not present
    let editBtn = document.getElementById('edit-bio-btn');
    if (!editBtn) {
      editBtn = document.createElement('button');
      editBtn.id = 'edit-bio-btn';
      editBtn.textContent = 'Edit Bio';
      editBtn.style = 'margin-top:10px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;';
    }
    // create Cancel button to appear while editing
    let cancelBtn = document.getElementById('cancel-bio-btn');
    if (!cancelBtn) {
      cancelBtn = document.createElement('button');
      cancelBtn.id = 'cancel-bio-btn';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style = 'margin-left:8px;background:#777;color:#fff;border:none;border-radius:6px;padding:6px 12px;cursor:pointer;display:none;';
    }

    // ensure the edit button sits before the bio container
    if (bioContainer && bioContainer.parentElement) {
      if (!editBtn.parentElement) bioContainer.parentElement.insertBefore(editBtn, bioContainer);
      if (!cancelBtn.parentElement) bioContainer.appendChild(cancelBtn);
      // hide the bio container (label + textarea + save) by default
      bioContainer.style.display = 'none';
      // show edit button
      editBtn.style.display = 'inline-block';
    }

    // open editor when clicking Edit
    editBtn.addEventListener('click', function() {
      // populate current text and show
      bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';
      bioContainer.style.display = 'block';
      editBtn.style.display = 'none';
      cancelBtn.style.display = 'inline-block';
      bioEdit.focus();
    });

    // cancel editing
    cancelBtn.addEventListener('click', function() {
      bioContainer.style.display = 'none';
      cancelBtn.style.display = 'none';
      editBtn.style.display = 'inline-block';
      // revert textarea to current character bio
      bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';
    });

    // After saving, hide the editor panel. Add only once.
    if (!saveBtn.dataset.hideAfterSave) {
      saveBtn.dataset.hideAfterSave = '1';
      saveBtn.addEventListener('click', function() {
        // small delay to allow the existing save handler to complete updates
        setTimeout(() => {
          bioContainer.style.display = 'none';
          cancelBtn.style.display = 'none';
          editBtn.style.display = 'inline-block';
          // update displayed bio from currentCharacter if available
          const newText = (currentCharacter && currentCharacter.bio) ? currentCharacter.bio : mainBioText;
          charBioDiv.innerHTML = escHtml(newText).replace(/\n/g, '<br>') +
            (storyBioText ? `<div style="margin-top:12px;color:#faa61a;white-space:pre-line;"><strong>Story Bio (GM):</strong><br>${escHtml(storyBioText).replace(/\n/g, '<br>')}</div>` : '');
        }, 250);
      });
    }
  }

      // Bonus logic
      const raceInfo = {
        "Human": { bonus: { strength: 1, dexterity: 1, constitution: 1 } },
        "Elf": { bonus: { dexterity: 2, intelligence: 1 } },
        "Dwarf": { bonus: { constitution: 2, strength: 1 } },
        "Halfling": { bonus: { dexterity: 2, charisma: 1 } },
        "Dragonborn": { bonus: { strength: 2, charisma: 1 } },
        "Gnome": { bonus: { intelligence: 2, constitution: 1 } },
        "Half-Elf": { bonus: { charisma: 2, dexterity: 1 } },
        "Half-Orc": { bonus: { strength: 2, constitution: 1 } },
        "Tiefling": { bonus: { charisma: 2, intelligence: 1 } }
      };
      const classInfo = {
        "Fighter": { bonus: { strength: 2 }, skill: "Athletics" },
        "Rogue": { bonus: { dexterity: 2 }, skill: "Stealth" },
        "Wizard": { bonus: { intelligence: 2 }, skill: "Arcana" },
        "Cleric": { bonus: { wisdom: 2 }, skill: "Religion" },
        "Barbarian": { bonus: { strength: 1, constitution: 1 }, skill: "Athletics" },
        "Bard": { bonus: { charisma: 2 }, skill: "Performance" },
        "Druid": { bonus: { wisdom: 1, constitution: 1 }, skill: "Nature" },
        "Monk": { bonus: { dexterity: 1, wisdom: 1 }, skill: "Acrobatics" },
        "Paladin": { bonus: { strength: 1, charisma: 1 }, skill: "Persuasion" },
        "Ranger": { bonus: { dexterity: 1, wisdom: 1 }, skill: "Survival" },
        "Sorcerer": { bonus: { charisma: 1, constitution: 1 }, skill: "Arcana" },
        "Warlock": { bonus: { charisma: 1, intelligence: 1 }, skill: "Intimidation" }
      };
      const backgroundInfo = {
        "Acolyte": { skills: ["Insight", "Religion"], bonus: { wisdom: 1 } },
        "Charlatan": { skills: ["Deception", "Sleight of Hand"], bonus: { charisma: 1 } },
        "Criminal": { skills: ["Deception", "Stealth"], bonus: { dexterity: 1 } },
        "Entertainer": { skills: ["Acrobatics", "Performance"], bonus: { charisma: 1 } },
        "Folk Hero": { skills: ["Animal Handling", "Survival"], bonus: { constitution: 1 } },
        "Guild Artisan": { skills: ["Insight", "Persuasion"], bonus: { intelligence: 1 } },
        "Hermit": { skills: ["Medicine", "Religion"], bonus: { wisdom: 1 } },
        "Noble": { skills: ["History", "Persuasion"], bonus: { charisma: 1 } },
        "Outlander": { skills: ["Athletics", "Survival"], bonus: { constitution: 1 } },
        "Sage": { skills: ["Arcana", "History"], bonus: { intelligence: 1 } },
        "Sailor": { skills: ["Athletics", "Perception"], bonus: { strength: 1 } },
        "Soldier": { skills: ["Athletics", "Intimidation"], bonus: { strength: 1 } },
        "Urchin": { skills: ["Sleight of Hand", "Stealth"], bonus: { dexterity: 1 } }
      };

      // Stats
      const statsTable = document.getElementById('stats-table');
      statsTable.innerHTML = '<tr><th style="width:30%;">Stat</th><th style="width:20%;">Total</th><th style="width:50%;"></th></tr>';
      
      // Level and XP display
      const levelRow = document.createElement('tr');
      const levelTh = document.createElement('th');
      levelTh.textContent = 'Level';
      const levelTd = document.createElement('td');
      levelTd.textContent = character.level ?? 1;
      const levelBreakdown = document.createElement('td');
      levelBreakdown.textContent = '';
      levelRow.appendChild(levelTh);
      levelRow.appendChild(levelTd);
      levelRow.appendChild(levelBreakdown);
      statsTable.appendChild(levelRow);
      
      const xpRow = document.createElement('tr');
      const xpTh = document.createElement('th');
      xpTh.textContent = 'XP';
      const xpTd = document.createElement('td');
      xpTd.textContent = character.xp ?? 0;
      const xpBreakdown = document.createElement('td');
      const currentLevel = character.level ?? 1;
      const xpForNextLevel = 100 * (currentLevel + 1);
      const currentXP = character.xp ?? 0;
      xpBreakdown.textContent = `[${xpForNextLevel - currentXP} needed for level ${currentLevel + 1}]`;
      xpRow.appendChild(xpTh);
      xpRow.appendChild(xpTd);
      xpRow.appendChild(xpBreakdown);
      statsTable.appendChild(xpRow);
      
      const statKeys = ['strength','dexterity','constitution','intelligence','wisdom','charisma'];
      statKeys.forEach(key => {
        let base = character[key] ?? 0;
        let bonus = 0;
        let breakdown = [];
        // Race bonus
        if (character.race && raceInfo[character.race] && raceInfo[character.race].bonus && raceInfo[character.race].bonus[key]) {
          bonus += raceInfo[character.race].bonus[key];
          breakdown.push(`Race +${raceInfo[character.race].bonus[key]}`);
        }
        // Class bonus
        if (character.class && classInfo[character.class] && classInfo[character.class].bonus && classInfo[character.class].bonus[key]) {
          bonus += classInfo[character.class].bonus[key];
          breakdown.push(`Class +${classInfo[character.class].bonus[key]}`);
        }
        // Background bonus
        if (character.background && backgroundInfo[character.background] && backgroundInfo[character.background].bonus && backgroundInfo[character.background].bonus[key]) {
          bonus += backgroundInfo[character.background].bonus[key];
          breakdown.push(`Background +${backgroundInfo[character.background].bonus[key]}`);
        }
        // Total value
        const total = base + bonus;
        const row = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key.charAt(0).toUpperCase() + key.slice(1);
        const tdTotal = document.createElement('td');
        tdTotal.textContent = total;
        const tdBreakdown = document.createElement('td');
        tdBreakdown.textContent = breakdown.length ? `[${breakdown.join(', ')}]` : '';
        row.appendChild(th);
        row.appendChild(tdTotal);
        row.appendChild(tdBreakdown);
        statsTable.appendChild(row);
      });
      // Weapons, Armor, Items as chips with tooltips
      // Render items as chips (using the general function)
      renderAssetChips('items', 'items-list', 'item-chip', 'items');
      
      // Create separate weapon and armor arrays from equipment
      let weapons = [];
      let armors = [];
      let miscEquipment = [];
      (Array.isArray(character.equipment) ? character.equipment : []).forEach(eq => {
        if ((eq.count ?? 0) > 0 && dndData) {
          const eqData = (dndData.equipment || []).find(e => e.name === eq.name);
          if (eqData && eqData.type && eqData.type.toLowerCase().includes('weapon')) {
            weapons.push(eq);
          } else if (eqData && eqData.type && eqData.type.toLowerCase().includes('armor')) {
            armors.push(eq);
          } else {
            miscEquipment.push(eq);
          }
        }
      });
      
      // Render weapon and armor chips
      const weaponsList = document.getElementById('weapons-list');
      const armorsList = document.getElementById('armors-list');
      const itemsList = document.getElementById('items-list');
      
      if (weaponsList) {
        weaponsList.innerHTML = '';
        const activeEffects = Array.isArray(character.status_effects) ? character.status_effects.map(e => e.name) : [];
        weapons.forEach(weapon => {
          let weaponData = (dndData && dndData.equipment) ? dndData.equipment.find(w => w.name === weapon.name) : null;
          let buffs = weaponData && weaponData.buffs ? weaponData.buffs.filter(b => activeEffects.includes(b)) : [];
          let debuffs = weaponData && weaponData.debuffs ? weaponData.debuffs.filter(d => activeEffects.includes(d)) : [];
          let label = weapon.name;
          let bracket = '';
          if ((weapon.count ?? 0) > 1) bracket = ` (${weapon.count})`;
          if (buffs.length > 0) label += ` <span class='buff-indicator' title='Buffed by: ${buffs.join(', ')}'>🟢</span>`;
          if (debuffs.length > 0) label += ` <span class='debuff-indicator' title='Debuffed by: ${debuffs.join(', ')}'>🔴</span>`;
          let tooltip = `${weapon.name}`;
          if (weaponData && weaponData.type) tooltip += `\nType: ${weaponData.type}`;
          if (weaponData && weaponData.damage) tooltip += `\nDamage: ${weaponData.damage}`;
          if (weaponData && weaponData.weight) tooltip += `\nWeight: ${weaponData.weight} lbs`;
          if (weaponData && weaponData.cost) tooltip += `\nCost: ${weaponData.cost}`;
          if (weaponData && weaponData.properties && weaponData.properties.length > 0) tooltip += `\nProperties: ${weaponData.properties.join(', ')}`;
          if (weaponData && weaponData.description) tooltip += `\n${weaponData.description}`;
          if ((weapon.count ?? 0) > 1) tooltip += `\nQuantity: ${weapon.count}`;
          if (weaponData && weaponData.buffs && weaponData.buffs.length > 0) tooltip += `\nCan be buffed by: ${weaponData.buffs.join(', ')}`;
          if (weaponData && weaponData.debuffs && weaponData.debuffs.length > 0) tooltip += `\nCan be debuffed by: ${weaponData.debuffs.join(', ')}`;
          if (buffs.length > 0) tooltip += `\nCurrently buffed by: ${buffs.join(', ')}`;
          if (debuffs.length > 0) tooltip += `\nCurrently debuffed by: ${debuffs.join(', ')}`;
          const chip = document.createElement('span');
          chip.className = 'weapon-chip';
          chip.innerHTML = label + bracket;
          chip.title = tooltip;
          weaponsList.appendChild(chip);
        });
        if (weapons.length === 0) weaponsList.innerHTML = '<span style="color:#888;">No weapons</span>';
      }
      
      if (armorsList) {
        armorsList.innerHTML = '';
        const activeEffects = Array.isArray(character.status_effects) ? character.status_effects.map(e => e.name) : [];
        armors.forEach(armor => {
          let armorData = (dndData && dndData.equipment) ? dndData.equipment.find(a => a.name === armor.name) : null;
          let buffs = armorData && armorData.buffs ? armorData.buffs.filter(b => activeEffects.includes(b)) : [];
          let debuffs = armorData && armorData.debuffs ? armorData.debuffs.filter(d => activeEffects.includes(d)) : [];
          let label = armor.name;
          let bracket = '';
          if ((armor.count ?? 0) > 1) bracket = ` (${armor.count})`;
          if (buffs.length > 0) label += ` <span class='buff-indicator' title='Buffed by: ${buffs.join(', ')}'>🟢</span>`;
          if (debuffs.length > 0) label += ` <span class='debuff-indicator' title='Debuffed by: ${debuffs.join(', ')}'>🔴</span>`;
          let tooltip = `${armor.name}`;
          if (armorData && armorData.type) tooltip += `\nType: ${armorData.type}`;
          if (armorData && armorData.ac) tooltip += `\nArmor Class: ${armorData.ac}`;
          if (armorData && armorData.ac_bonus) tooltip += `\nAC Bonus: +${armorData.ac_bonus}`;
          if (armorData && armorData.dex_bonus !== undefined) tooltip += `\nDexterity Bonus: ${armorData.dex_bonus ? 'Yes' : 'No'}`;
          if (armorData && armorData.strength_req) tooltip += `\nStrength Requirement: ${armorData.strength_req}`;
          if (armorData && armorData.stealth_disadvantage) tooltip += `\nStealth: Disadvantage`;
          if (armorData && armorData.weight) tooltip += `\nWeight: ${armorData.weight} lbs`;
          if (armorData && armorData.cost) tooltip += `\nCost: ${armorData.cost}`;
          if (armorData && armorData.description) tooltip += `\n${armorData.description}`;
          if ((armor.count ?? 0) > 1) tooltip += `\nQuantity: ${armor.count}`;
          if (armorData && armorData.buffs && armorData.buffs.length > 0) tooltip += `\nCan be buffed by: ${armorData.buffs.join(', ')}`;
          if (armorData && armorData.debuffs && armorData.debuffs.length > 0) tooltip += `\nCan be debuffed by: ${armorData.debuffs.join(', ')}`;
          if (buffs.length > 0) tooltip += `\nCurrently buffed by: ${buffs.join(', ')}`;
          if (debuffs.length > 0) tooltip += `\nCurrently debuffed by: ${debuffs.join(', ')}`;
          const chip = document.createElement('span');
          chip.className = 'armor-chip';
          chip.innerHTML = label + bracket;
          chip.title = tooltip;
          armorsList.appendChild(chip);
        });
        if (armors.length === 0) armorsList.innerHTML = '<span style="color:#888;">No armor</span>';
      }
      
      // Add misc equipment to items display
      if (miscEquipment.length > 0 && itemsList) {
        miscEquipment.forEach(eq => {
          let eqData = (dndData && dndData.equipment) ? dndData.equipment.find(e => e.name === eq.name) : null;
          let label = eq.name;
          let bracket = '';
          if ((eq.count ?? 0) > 1) bracket = ` (${eq.count})`;
          let tooltip = '';
          if (eqData && eqData.description) tooltip += eqData.description;
          if (eqData && eqData.type) tooltip += (tooltip ? '\n' : '') + 'Type: ' + eqData.type;
          const chip = document.createElement('span');
          chip.className = 'equipment-chip';
          chip.innerHTML = label + bracket;
          if (tooltip) chip.title = tooltip;
          itemsList.appendChild(chip);
        });
      }
      // --- Skills & Spells as Chips with Buff/Debuff and Tooltips ---
      const skillsTable = document.getElementById('skills-table');
      const spellsTable = document.getElementById('spells-table');
      // Add chip style if not present
      (function addSkillSpellChipStyle() {
        if (document.getElementById('skill-spell-chip-style')) return;
        const style = document.createElement('style');
        style.id = 'skill-spell-chip-style';
        style.textContent = `.skill-chip, .spell-chip, .weapon-chip, .armor-chip, .item-chip, .equipment-chip { display:inline-block;background:#444;color:#fff;padding:4px 10px;margin:2px 4px 2px 0;border-radius:8px;font-size:0.98em;cursor:help;transition:background 0.2s; }
        .skill-chip:hover, .spell-chip:hover, .weapon-chip:hover, .armor-chip:hover, .item-chip:hover, .equipment-chip:hover { background:#7289da;color:#fff; }
        .buff-indicator { margin-left:4px; color:#43b581; font-size:1.1em; cursor:help; }
        .debuff-indicator { margin-left:4px; color:#f04747; font-size:1.1em; cursor:help; }`;
        document.head.appendChild(style);
      })();
      // Skills
      if (skillsTable) {
        skillsTable.innerHTML = '';
        const activeEffects = Array.isArray(character.status_effects) ? character.status_effects.map(e => e.name) : [];
        (Array.isArray(character.skills) ? character.skills : []).forEach(skill => {
          let bonus = 0;
          let sources = [];
          // Class bonus
          if (character.class && classInfo[character.class] && classInfo[character.class].skill === skill.name) {
            bonus += 2;
            sources.push('Class +2');
          }
          // Background bonus
          if (character.background && backgroundInfo[character.background] && backgroundInfo[character.background].skills && backgroundInfo[character.background].skills.includes(skill.name)) {
            bonus += 2;
            sources.push('Background +2');
          }
          if ((skill.count ?? 0) > 0 || bonus > 0) {
            let skillData = (dndData && dndData.skills) ? dndData.skills.find(s => s.name === skill.name) : null;
            let buffs = skillData && skillData.buffs ? skillData.buffs.filter(b => activeEffects.includes(b)) : [];
            let debuffs = skillData && skillData.debuffs ? skillData.debuffs.filter(d => activeEffects.includes(d)) : [];
            let label = skill.name;
            let bracket = '';
            if (bonus > 0) bracket = ` [${sources.join(', ')}]`;
            if (buffs.length > 0) label += ` <span class='buff-indicator' title='Buffed by: ${buffs.join(', ')}'>🟢</span>`;
            if (debuffs.length > 0) label += ` <span class='debuff-indicator' title='Debuffed by: ${debuffs.join(', ')}'>🔴</span>`;
            // Tooltip: show skill info, ability, bonuses, buffs, debuffs
            let tooltip = `${skill.name}`;
            if (skillData && skillData.ability) tooltip += ` (${skillData.ability})`;
            if (skillData && skillData.description) tooltip += `\n${skillData.description}`;
            if (skill.count && skill.count > 0) tooltip += `\nSkill Level: ${skill.count}`;
            if (bonus > 0) tooltip += `\nBonuses: ${sources.join(', ')}`;
            if (skillData && skillData.buffs && skillData.buffs.length > 0) tooltip += `\nCan be buffed by: ${skillData.buffs.join(', ')}`;
            if (skillData && skillData.debuffs && skillData.debuffs.length > 0) tooltip += `\nCan be debuffed by: ${skillData.debuffs.join(', ')}`;
            if (buffs.length > 0) tooltip += `\nCurrently buffed by: ${buffs.join(', ')}`;
            if (debuffs.length > 0) tooltip += `\nCurrently debuffed by: ${debuffs.join(', ')}`;
            const chip = document.createElement('span');
            chip.className = 'skill-chip';
            chip.innerHTML = label + bracket;
            chip.title = tooltip;
            skillsTable.appendChild(chip);
          }
        });
      }
      // Spells
      if (spellsTable) {
        spellsTable.innerHTML = '';
        const activeEffects = Array.isArray(character.status_effects) ? character.status_effects.map(e => e.name) : [];
        (Array.isArray(character.spells) ? character.spells : []).forEach(spell => {
          if ((spell.count ?? 0) > 0) {
            let spellData = (dndData && dndData.spells) ? dndData.spells.find(s => s.name === spell.name) : null;
            let buffs = spellData && spellData.buffs ? spellData.buffs.filter(b => activeEffects.includes(b)) : [];
            let debuffs = spellData && spellData.debuffs ? spellData.debuffs.filter(d => activeEffects.includes(d)) : [];
            let label = spell.name;
            let bracket = '';
            let level = spellData && spellData.level ? spellData.level : (spell.level ?? '');
            if (level) bracket = ` [Level ${level}]`;
            if (buffs.length > 0) label += ` <span class='buff-indicator' title='Buffed by: ${buffs.join(', ')}'>🟢</span>`;
            if (debuffs.length > 0) label += ` <span class='debuff-indicator' title='Debuffed by: ${debuffs.join(', ')}'>🔴</span>`;
            // Tooltip: show spell info, level, school, description, buffs, debuffs
            let tooltip = `${spell.name}`;
            if (level) tooltip += ` (Level ${level})`;
            if (spellData && spellData.school) tooltip += `\nSchool: ${spellData.school}`;
            if (spellData && spellData.description) tooltip += `\n${spellData.description}`;
            if (spellData && spellData.casting_time) tooltip += `\nCasting Time: ${spellData.casting_time}`;
            if (spellData && spellData.range) tooltip += `\nRange: ${spellData.range}`;
            if (spellData && spellData.components) tooltip += `\nComponents: ${spellData.components}`;
            if (spellData && spellData.duration) tooltip += `\nDuration: ${spellData.duration}`;
            if (spellData && spellData.buffs && spellData.buffs.length > 0) tooltip += `\nCan be buffed by: ${spellData.buffs.join(', ')}`;
            if (spellData && spellData.debuffs && spellData.debuffs.length > 0) tooltip += `\nCan be debuffed by: ${spellData.debuffs.join(', ')}`;
            if (buffs.length > 0) tooltip += `\nCurrently buffed by: ${buffs.join(', ')}`;
            if (debuffs.length > 0) tooltip += `\nCurrently debuffed by: ${debuffs.join(', ')}`;
            const chip = document.createElement('span');
            chip.className = 'spell-chip';
            chip.innerHTML = label + bracket;
            chip.title = tooltip;
            spellsTable.appendChild(chip);
          }
        });
      }
      attachTooltipListeners();
    }
    // Tooltip logic
    function getTooltipContent(type, name) {
      if (!dndData) return '';
      let entry = null;
      if (type === 'items') entry = (dndData.items || []).find(i => i.name === name);
      else if (type === 'equipment') entry = (dndData.equipment || []).find(e => e.name === name);
      else if (type === 'skills') entry = (dndData.skills || []).find(s => s.name === name);
      else if (type === 'spells') entry = (dndData.spells || []).find(sp => sp.name === name);
      if (!entry) return '';
      let html = `<b>${entry.name}</b><br>`;
      if (type === 'items' || type === 'equipment') {
        if (entry.type) html += `<i>Type:</i> ${entry.type}<br>`;
        if (entry.damage) html += `<i>Damage:</i> ${entry.damage}<br>`;
        if (entry.ac) html += `<i>AC:</i> ${entry.ac}<br>`;
        if (entry.ac_bonus) html += `<i>AC Bonus:</i> ${entry.ac_bonus}<br>`;
        if (entry.dex_bonus) html += `<i>Dex Bonus:</i> Yes<br>`;
        if (entry.strength_req) html += `<i>Strength Req:</i> ${entry.strength_req}<br>`;
        if (entry.stealth_disadvantage) html += `<i>Stealth Disadvantage:</i> Yes<br>`;
        if (entry.effect) html += `<i>Effect:</i> ${entry.effect}<br>`;
        if (entry.properties) html += `<i>Properties:</i> ${entry.properties.join(', ')}<br>`;
      }
      if (type === 'skills') {
        if (entry.ability) html += `<i>Ability:</i> ${entry.ability}<br>`;
        if (Array.isArray(entry.effects)) {
          html += `<b>Buffs/Debuffs:</b><br>`;
          entry.effects.forEach(eff => {
            let color = eff.type === 'buff' ? '#43b581' : '#f04747';
            let effectText = eff.effect_type === 'advantage' ? 'Advantage (roll twice, take higher)' :
              eff.effect_type === 'disadvantage' ? 'Disadvantage (roll twice, take lower)' :
              (eff.effect_type === 'modifier' ? (eff.value > 0 ? `+${eff.value}` : `${eff.value}`) : '');
            html += `<span style='color:${color}'>${eff.source}: ${effectText}</span><br>`;
          });
        }
      }
      if (type === 'spells') {
        if (entry.level) html += `<i>Level:</i> ${entry.level}<br>`;
        if (entry.school) html += `<i>School:</i> ${entry.school}<br>`;
        if (entry.description) html += `<i>Description:</i> ${entry.description}<br>`;
        if (Array.isArray(entry.buffs_granted) && entry.buffs_granted.length) {
          html += `<b>Buffs Granted:</b> ${entry.buffs_granted.join(', ')}<br>`;
        }
        if (Array.isArray(entry.debuffs_granted) && entry.debuffs_granted.length) {
          html += `<b>Debuffs Granted:</b> ${entry.debuffs_granted.join(', ')}<br>`;
        }
        if (Array.isArray(entry.buffs_removed) && entry.buffs_removed.length) {
          html += `<b>Buffs Removed:</b> ${entry.buffs_removed.join(', ')}<br>`;
        }
        if (Array.isArray(entry.debuffs_removed) && entry.debuffs_removed.length) {
          html += `<b>Debuffs Removed:</b> ${entry.debuffs_removed.join(', ')}<br>`;
        }
        if (entry.hp_change) html += `<b>HP Change:</b> ${entry.hp_change}<br>`;
      }
      return html;
    }

    // Render assets (items, weapons, armor) as chips with tooltips
    function renderAssetChips(assetType, containerId, chipClass, dndKey) {
      const div = document.getElementById(containerId);
      if (!div) return;
      div.innerHTML = '';
      const activeEffects = Array.isArray(character.status_effects) ? character.status_effects.map(e => e.name) : [];
      (Array.isArray(character[assetType]) ? character[assetType] : []).forEach(asset => {
        if ((asset.count ?? 0) > 0 || asset.name) {
          let assetData = (dndData && dndData[dndKey]) ? dndData[dndKey].find(a => a.name === asset.name) : null;
          let buffs = assetData && assetData.buffs ? assetData.buffs.filter(b => activeEffects.includes(b)) : [];
          let debuffs = assetData && assetData.debuffs ? assetData.debuffs.filter(d => activeEffects.includes(d)) : [];
          let label = asset.name;
          let bracket = '';
          // Show count in brackets if > 1
          if ((asset.count ?? 0) > 1) bracket = ` (${asset.count})`;
          // Show bonus in brackets if present
          let bonus = 0;
          let sources = [];
          if (assetData && assetData.bonus) {
            bonus += assetData.bonus;
            sources.push('Bonus +' + assetData.bonus);
          }
          if (bonus > 0) bracket += ` [${sources.join(', ')}]`;
          if (buffs.length > 0) label += ` <span class='buff-indicator' title='Buffed by: ${buffs.join(', ')}'>🟢</span>`;
          if (debuffs.length > 0) label += ` <span class='debuff-indicator' title='Debuffed by: ${debuffs.join(', ')}'>🔴</span>`;
          // Tooltip: use dndData for description, bonuses, buffs, debuffs
          let tooltip = `${asset.name}`;
          if (assetData && assetData.type) tooltip += `\nType: ${assetData.type}`;
          if (assetData && assetData.category) tooltip += `\nCategory: ${assetData.category}`;
          if (assetData && assetData.weight) tooltip += `\nWeight: ${assetData.weight} lbs`;
          if (assetData && assetData.cost) tooltip += `\nCost: ${assetData.cost}`;
          if (assetData && assetData.rarity) tooltip += `\nRarity: ${assetData.rarity}`;
          if (assetData && assetData.description) tooltip += `\n${assetData.description}`;
          if ((asset.count ?? 0) > 1) tooltip += `\nQuantity: ${asset.count}`;
          if (bonus > 0) tooltip += `\nBonuses: ${sources.join(', ')}`;
          if (assetData && assetData.buffs && assetData.buffs.length > 0) tooltip += `\nCan be buffed by: ${assetData.buffs.join(', ')}`;
          if (assetData && assetData.debuffs && assetData.debuffs.length > 0) tooltip += `\nCan be debuffed by: ${assetData.debuffs.join(', ')}`;
          if (buffs.length > 0) tooltip += `\nCurrently buffed by: ${buffs.join(', ')}`;
          if (debuffs.length > 0) tooltip += `\nCurrently debuffed by: ${debuffs.join(', ')}`;
          const chip = document.createElement('span');
          chip.className = chipClass;
          chip.innerHTML = label + bracket;
          chip.title = tooltip;
          div.appendChild(chip);
        }
      });
    }

  // ...existing code...
  </script>
</body>
</html>