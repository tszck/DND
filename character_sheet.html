<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>RPG Character Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js/dist/umd/supabase.min.js"></script>
  <script src="supabase.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #23272a;
      color: #fff;
      margin: 0;
      padding: 0;
    }
    .dashboard {
      max-width: 900px;
      margin: 40px auto;
      background: #2c2f33;
      border-radius: 12px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.4);
      padding: 32px;
  display: grid;
  grid-template-columns: 1fr 2fr;
  gap: 32px;
    }
    .profile {
      text-align: center;
    }
    .profile img {
      width: 120px;
      border-radius: 50%;
      border: 4px solid #7289da;
      margin-bottom: 16px;
    }
    .profile h2 {
      margin: 0;
      font-size: 2em;
      color: #7289da;
    }
    .stats, .inventory, .abilities {
  margin-bottom: 24px;
  text-align: left;
    }
    .stats table {
      width: 100%;
      border-collapse: collapse;
      table-layout: fixed;
    }
    .stats th, .stats td {
      padding: 8px;
      text-align: left;
      border-bottom: 1px solid #444;
    }
    .stats th:first-child { width: 30%; }
    .stats th:nth-child(2) { width: 20%; }
    .stats th:nth-child(3) { width: 50%; }
    .section-title {
      font-size: 1.2em;
      color: #43b581;
      margin-bottom: 8px;
      border-bottom: 2px solid #43b581;
      display: inline-block;
      padding-bottom: 2px;
    }
    .inventory ul, .abilities ul {
      list-style: none;
      padding: 0;
    }
    .inventory li, .abilities li {
      background: #23272a;
      margin-bottom: 6px;
      padding: 8px;
      border-radius: 6px;
      border-left: 4px solid #7289da;
    }
    /* Tooltip styles */
    .tooltip {
      position: absolute;
      background: #23272a;
      color: #fff;
      border: 1px solid #7289da;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 0.95em;
      z-index: 1000;
      pointer-events: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
      max-width: 320px;
      display: none;
    }
  </style>
</head>
<body>
  <div class="dashboard">
    <div class="profile">
    <img id="avatar-img" src="avatar.png" alt="Character Avatar">
    <input type="file" id="avatar-upload" accept="image/png, image/jpeg" style="margin-top:10px;">
      <h2 id="char-name"></h2>
      <p id="char-class"></p>
      <div id="char-summary" style="margin-top:10px;color:#43b581;font-size:1em;"></div>
      <div id="char-bio" style="margin-top:18px;padding:10px;background:#23272a;border-radius:8px;color:#b9bbbe;font-size:1em;white-space:pre-line;"></div>
      <div style="margin-top:18px;">
        <label for="bio-edit" style="color:#43b581;font-size:1em;">Bio / Notes:</label>
        <textarea id="bio-edit" rows="3" style="width:100%;margin-top:4px;border-radius:4px;padding:8px;background:#23272a;color:#b9bbbe;font-size:1em;"></textarea>
        <button id="save-bio-btn" style="margin-top:6px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;">Save Bio</button>
      </div>
      <button id="printSheetBtn" style="margin-top:18px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;">Print Character Sheet</button>
    </div>
      <!-- Avatar removed: file not found -->
    <div>
  <div class="stats" style="text-align:left;">
        <div class="section-title">Stats</div>
        <table id="stats-table"></table>
        <div class="section-title">Add/Remove</div>
        <form id="addForm" style="margin-bottom:24px;display:flex;flex-wrap:nowrap;align-items:center;gap:8px;">
          <label for="type" style="margin:0 4px 0 0;">Type:</label>
          <select id="type" name="type" style="flex:0 0 20%;max-width:100px;max-width:40%;">
            <option value="items">Item</option>
            <option value="equipment">Equipment</option>
            <option value="skills">Skill</option>
            <option value="spells">Spell</option>
            <option value="xp">XP</option>
              <option value="stats">Allocate Stat Point</option>
          </select>
          <label for="suggestion">Name:</label>
          <input type="text" id="suggestion" name="suggestion" list="suggestions" autocomplete="off" required>
          <datalist id="suggestions"></datalist>
          <label for="count" style="margin:0 4px 0 0;">Count:</label>
          <input type="number" id="count" name="count" min="1" value="1" required style="width:3ch;min-width:40px;max-width:48px;text-align:center;">
          <button type="submit" style="background: #43b581;">Add</button>
          <button type="button" id="removeBtn" style="background: #f04747; margin-left: 2px;">Remove</button>
        </form>
      </div>
      <div class="inventory">
  <div class="section-title" style="text-align:left;">Weapons</div>
  <table id="weapons-table" style="width:100%;margin-bottom:12px;"></table>
  <div class="section-title">Armor</div>
  <table id="armor-table" style="width:100%;margin-bottom:12px;"></table>
  <div class="section-title">Items</div>
  <table id="items-table" style="width:100%;margin-bottom:12px;"></table>
      </div>
      <div class="abilities">
  <div class="section-title" style="text-align:left;">Skills</div>
  <table id="skills-table" style="width:100%;margin-bottom:12px;"></table>
  <div class="section-title">Spells</div>
  <table id="spells-table" style="width:100%;margin-bottom:12px;"></table>
      </div>
    </div>
  </div>
  <div id="sheet-data" style="margin:32px 0;"></div>
  <div id="tooltip" class="tooltip"></div>
  <script>
    // Bio edit/save logic
    document.addEventListener('DOMContentLoaded', function() {
      const bioEdit = document.getElementById('bio-edit');
      const saveBioBtn = document.getElementById('save-bio-btn');
      if (saveBioBtn && bioEdit) {
        saveBioBtn.addEventListener('click', async function() {
          if (!currentCharacter || !currentUsername) return;
          const newBio = bioEdit.value.trim();
          await updateCharacter(currentUsername, { bio: newBio });
          currentCharacter.bio = newBio;
          document.getElementById('char-bio').textContent = newBio || 'The tale of this adventurer is yet to be written...';
          alert('Bio updated!');
        });
      }
    });
    // Avatar upload logic
    document.addEventListener('DOMContentLoaded', function() {
      const avatarInput = document.getElementById('avatar-upload');
      if (avatarInput) {
        avatarInput.addEventListener('change', async function(e) {
          const file = e.target.files[0];
          if (!file) return;
          if (!['image/jpeg','image/png'].includes(file.type)) {
            alert('Only JPEG and PNG images allowed.');
            return;
          }
          if (file.size > 200*1024) {
            alert('Image must be under 200KB.');
            return;
          }
          // Resize image to max 256x256px
          const img = new Image();
          img.onload = async function() {
            const canvas = document.createElement('canvas');
            const maxDim = 256;
            let w = img.width, h = img.height;
            if (w > maxDim || h > maxDim) {
              if (w > h) {
                h = Math.round(h * (maxDim / w));
                w = maxDim;
              } else {
                w = Math.round(w * (maxDim / h));
                h = maxDim;
              }
            }
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, w, h);
            canvas.toBlob(async function(blob) {
              // Upload to Supabase Storage
              const fileExt = file.type === 'image/png' ? 'png' : 'jpg';
              const fileName = `avatar_${currentUsername}.${fileExt}`;
              // Use supabase.js client
              const { data, error } = await supabaseClient.storage.from('avatars').upload(fileName, blob, {
                upsert: true,
                contentType: file.type
              });
              if (error) {
                alert('Upload failed: ' + error.message);
                return;
              }
              // Get public URL
              const { publicURL } = supabaseClient.storage.from('avatars').getPublicUrl(fileName);
              // Save URL to character
              await updateCharacter(currentUsername, { avatar_url: publicURL });
              currentCharacter.avatar_url = publicURL;
              document.getElementById('avatar-img').src = publicURL;
              alert('Avatar updated!');
            }, file.type, 0.92);
          };
          const reader = new FileReader();
          reader.onload = function(ev) { img.src = ev.target.result; };
          reader.readAsDataURL(file);
        });
      }
    });
  // Suggestions infrastructure
    // Print Character Sheet logic
    document.addEventListener('DOMContentLoaded', function() {
      const printBtn = document.getElementById('printSheetBtn');
      if (printBtn) {
        printBtn.addEventListener('click', function() {
          if (currentCharacter) openPrintableCharacterSheet(currentCharacter);
        });
      }
    });

    function openPrintableCharacterSheet(character) {
      const printWindow = window.open('', '_blank', 'width=800,height=1000,scrollbars=yes');
      // Stat bonus logic
      const raceInfo = {
        "Human": { bonus: { strength: 1, dexterity: 1, constitution: 1 } },
        "Elf": { bonus: { dexterity: 2, intelligence: 1 } },
        "Dwarf": { bonus: { constitution: 2, strength: 1 } },
        "Halfling": { bonus: { dexterity: 2, charisma: 1 } },
        "Dragonborn": { bonus: { strength: 2, charisma: 1 } },
        "Gnome": { bonus: { intelligence: 2, constitution: 1 } },
        "Half-Elf": { bonus: { charisma: 2, dexterity: 1 } },
        "Half-Orc": { bonus: { strength: 2, constitution: 1 } },
        "Tiefling": { bonus: { charisma: 2, intelligence: 1 } }
      };
      const classInfo = {
        "Fighter": { bonus: { strength: 2 } },
        "Rogue": { bonus: { dexterity: 2 } },
        "Wizard": { bonus: { intelligence: 2 } },
        "Cleric": { bonus: { wisdom: 2 } },
        "Barbarian": { bonus: { strength: 1, constitution: 1 } },
        "Bard": { bonus: { charisma: 2 } },
        "Druid": { bonus: { wisdom: 1, constitution: 1 } },
        "Monk": { bonus: { dexterity: 1, wisdom: 1 } },
        "Paladin": { bonus: { strength: 1, charisma: 1 } },
        "Ranger": { bonus: { dexterity: 1, wisdom: 1 } },
        "Sorcerer": { bonus: { charisma: 1, constitution: 1 } },
        "Warlock": { bonus: { charisma: 1, intelligence: 1 } }
      };
      const backgroundInfo = {
        "Acolyte": { bonus: { wisdom: 1 } },
        "Charlatan": { bonus: { charisma: 1 } },
        "Criminal": { bonus: { dexterity: 1 } },
        "Entertainer": { bonus: { charisma: 1 } },
        "Folk Hero": { bonus: { constitution: 1 } },
        "Guild Artisan": { bonus: { intelligence: 1 } },
        "Hermit": { bonus: { wisdom: 1 } },
        "Noble": { bonus: { charisma: 1 } },
        "Outlander": { bonus: { constitution: 1 } },
        "Sage": { bonus: { intelligence: 1 } },
        "Sailor": { bonus: { strength: 1 } },
        "Soldier": { bonus: { strength: 1 } },
        "Urchin": { bonus: { dexterity: 1 } }
      };

      function getTotalStat(character, stat) {
        let total = character[stat] || 0;
        if (raceInfo[character.race] && raceInfo[character.race].bonus && raceInfo[character.race].bonus[stat]) {
          total += raceInfo[character.race].bonus[stat];
        }
        if (classInfo[character.class] && classInfo[character.class].bonus && classInfo[character.class].bonus[stat]) {
          total += classInfo[character.class].bonus[stat];
        }
        if (backgroundInfo[character.background] && backgroundInfo[character.background].bonus && backgroundInfo[character.background].bonus[stat]) {
          total += backgroundInfo[character.background].bonus[stat];
        }
        return total;
      }

      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>${character.name || character.username} - Character Sheet</title>
          <style>
            @media print {
              body { margin: 0; }
              .no-print { display: none; }
            }
            body { 
              font-family: 'Times New Roman', serif; 
              margin: 20px; 
              background: white; 
              color: black; 
              line-height: 1.4;
            }
            .header { 
              text-align: center; 
              border-bottom: 3px solid #000; 
              padding-bottom: 10px; 
              margin-bottom: 20px; 
            }
            .character-name { 
              font-size: 28px; 
              font-weight: bold; 
              margin: 0; 
            }
            .character-details { 
              font-size: 16px; 
              margin: 5px 0; 
            }
            .section { 
              margin-bottom: 20px; 
              border: 2px solid #000; 
              padding: 10px; 
            }
            .section-title { 
              font-size: 18px; 
              font-weight: bold; 
              border-bottom: 1px solid #000; 
              margin-bottom: 10px; 
              padding-bottom: 5px; 
            }
            .stats-grid { 
              display: grid; 
              grid-template-columns: repeat(3, 1fr); 
              gap: 10px; 
            }
            .stat-box { 
              border: 1px solid #000; 
              padding: 8px; 
              text-align: center; 
            }
            .stat-name { 
              font-weight: bold; 
              font-size: 12px; 
            }
            .stat-value { 
              font-size: 20px; 
              font-weight: bold; 
            }
            .equipment-list { 
              columns: 2; 
              column-gap: 20px; 
            }
            .equipment-item { 
              break-inside: avoid; 
              margin-bottom: 5px; 
            }
            .no-print { 
              position: fixed; 
              top: 10px; 
              right: 10px; 
            }
            button { 
              padding: 10px 20px; 
              font-size: 16px; 
              cursor: pointer; 
            }
          </style>
        </head>
        <body>
          <button class="no-print" onclick="window.print()">Print Character Sheet</button>
          <div class="header">
            <h1 class="character-name">${character.name || character.username}</h1>
            <div class="character-details">
              Level ${character.level} ${character.race} ${character.class}
            </div>
            <div class="character-details">
              Background: ${character.background} | Username: ${character.username}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Ability Scores</div>
            <div class="stats-grid">
              <div class="stat-box">
                <div class="stat-name">STRENGTH</div>
                <div class="stat-value">${getTotalStat(character, 'strength')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">DEXTERITY</div>
                <div class="stat-value">${getTotalStat(character, 'dexterity')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">CONSTITUTION</div>
                <div class="stat-value">${getTotalStat(character, 'constitution')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">INTELLIGENCE</div>
                <div class="stat-value">${getTotalStat(character, 'intelligence')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">WISDOM</div>
                <div class="stat-value">${getTotalStat(character, 'wisdom')}</div>
              </div>
              <div class="stat-box">
                <div class="stat-name">CHARISMA</div>
                <div class="stat-value">${getTotalStat(character, 'charisma')}</div>
              </div>
            </div>
          </div>
          <div class="section">
            <div class="section-title">Character Progress</div>
            <p><strong>Level:</strong> ${character.level}</p>
            <p><strong>Experience Points:</strong> ${character.xp || 0}</p>
            <p><strong>XP to Next Level:</strong> ${(100 * (character.level + 1)) - (character.xp || 0)}</p>
            <p><strong>Free Stat Points:</strong> ${character.free_stat_points || 0}</p>
          </div>
          <div class="section">
            <div class="section-title">Equipment & Items</div>
            <div class="equipment-list">
              ${character.equipment ? character.equipment.filter(eq => eq.count > 0).map(eq => 
                `<div class="equipment-item">${eq.name} (${eq.count})</div>`
              ).join('') : '<div>No equipment</div>'}
              ${character.items ? character.items.filter(item => item.count > 0).map(item => 
                `<div class="equipment-item">${item.name} (${item.count})</div>`
              ).join('') : ''}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Skills & Spells</div>
            <div class="equipment-list">
              ${character.skills ? character.skills.filter(skill => skill.count > 0).map(skill => 
                `<div class="equipment-item">${skill.name} (Level ${skill.count})</div>`
              ).join('') : '<div>No skills</div>'}
              ${character.spells ? character.spells.filter(spell => spell.count > 0).map(spell => 
                `<div class="equipment-item">${spell.name}</div>`
              ).join('') : ''}
            </div>
          </div>
          <div class="section">
            <div class="section-title">Notes</div>
            <div style="height: 150px; border: 1px solid #ccc; padding: 10px;">
              ${character.bio || 'The tale of this adventurer is yet to be written...'}
            </div>
          </div>
        </body>
        </html>
      `);
      printWindow.document.close();
    }
    let sheetSuggestions = { items: [], equipment: [], skills: [], spells: [], xp: ['Experience Points'] };
    let dndData = null;
    async function loadSuggestions() {
      try {
        const res = await fetch('dnd_data.json');
        const data = await res.json();
        dndData = data;
        sheetSuggestions.items = (data.items || []).map(i => i.name);
        sheetSuggestions.equipment = (data.equipment || []).map(e => e.name);
        sheetSuggestions.skills = (data.skills || []).map(s => s.name);
        sheetSuggestions.spells = (data.spells || []).map(sp => sp.name);
        updateSuggestionsList('items');
      } catch (err) {
        console.error('Failed to load suggestions:', err);
      }
    }
    window.addEventListener('DOMContentLoaded', function() {
      loadSuggestions();
    });
    document.getElementById('type').addEventListener('change', function() {
      updateSuggestionsList(this.value);
        // If stats selected, show stat keys as suggestions
        if (this.value === 'stats') {
          const datalist = document.getElementById('suggestions');
          datalist.innerHTML = '';
          ['Strength','Dexterity','Constitution','Intelligence','Wisdom','Charisma'].forEach(s => {
            const option = document.createElement('option');
            option.value = s;
            datalist.appendChild(option);
          });
        }
    });
    function updateSuggestionsList(type) {
      const datalist = document.getElementById('suggestions');
      datalist.innerHTML = '';
      sheetSuggestions[type].forEach(s => {
        const option = document.createElement('option');
        option.value = s;
        datalist.appendChild(option);
      });
    }
    // Manual add logic
    document.getElementById('addForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      const type = document.getElementById('type').value;
      const name = document.getElementById('suggestion').value.trim();
      const count = parseInt(document.getElementById('count').value);
      
      if (!name || !count || !currentCharacter || !currentUsername) return;
      
      try {
          // Stat allocation logic
          if (["strength","dexterity","constitution","intelligence","wisdom","charisma"].includes(name.toLowerCase()) && type === 'stats') {
            if ((currentCharacter.free_stat_points ?? 0) < count) {
              alert('Not enough free stat points to allocate.');
              return;
            }
            let statKey = name.toLowerCase();
            let newValue = (currentCharacter[statKey] ?? 0) + count;
            let newPoints = (currentCharacter.free_stat_points ?? 0) - count;
            await updateCharacter(currentUsername, { [statKey]: newValue, free_stat_points: newPoints });
            currentCharacter[statKey] = newValue;
            currentCharacter.free_stat_points = newPoints;
            renderCharacterSheet(currentCharacter);
            return;
          }
        // Update the character data based on type
        if (type === 'items') {
          await addItemToCharacter(name, count);
        } else if (type === 'equipment') {
          await addEquipmentToCharacter(name, count);
        } else if (type === 'skills') {
          await addSkillToCharacter(name, count);
        } else if (type === 'spells') {
          await addSpellToCharacter(name, count);
        } else if (type === 'xp') {
          await addXPToCharacter(count);
        }
        
        // Reset form
        this.reset();
        updateSuggestionsList(document.getElementById('type').value);
      } catch (error) {
        console.error('Error adding item:', error);
        alert('Failed to add item. Please try again.');
      }
    });

    // Remove button logic
    document.getElementById('removeBtn').addEventListener('click', async function(e) {
      e.preventDefault();
      const type = document.getElementById('type').value;
      const name = document.getElementById('suggestion').value.trim();
      const count = parseInt(document.getElementById('count').value);
      
      if (!name || !count || !currentCharacter || !currentUsername) return;
      
      try {
        // Stat point removal logic
        if (["strength","dexterity","constitution","intelligence","wisdom","charisma"].includes(name.toLowerCase()) && type === 'stats') {
          let statKey = name.toLowerCase();
          let currentValue = currentCharacter[statKey] ?? 0;
          if (currentValue < count) {
            alert('Cannot remove more stat points than currently allocated.');
            return;
          }
          let newValue = currentValue - count;
          let newPoints = (currentCharacter.free_stat_points ?? 0) + count;
          await updateCharacter(currentUsername, { [statKey]: newValue, free_stat_points: newPoints });
          currentCharacter[statKey] = newValue;
          currentCharacter.free_stat_points = newPoints;
          renderCharacterSheet(currentCharacter);
          return;
        }
        // ...existing code...
        let items = [];
        if (type === 'items') items = currentCharacter.items || [];
        else if (type === 'equipment') items = currentCharacter.equipment || [];
        else if (type === 'skills') items = currentCharacter.skills || [];
        else if (type === 'spells') items = currentCharacter.spells || [];
        else if (type === 'xp') {
          if ((currentCharacter.xp || 0) === 0) {
            alert(`No XP to remove.`);
            return;
          }
        }
        
        if (type !== 'xp') {
          const existingItem = items.find(item => item.name === name);
          if (!existingItem || (existingItem.count || 0) === 0) {
            alert(`No ${name} to remove.`);
            return;
          }
        }
        
        // Remove from the character data based on type
        if (type === 'items') {
          await removeItemFromCharacter(name, count);
        } else if (type === 'equipment') {
          await removeEquipmentFromCharacter(name, count);
        } else if (type === 'skills') {
          await removeSkillFromCharacter(name, count);
        } else if (type === 'spells') {
          await removeSpellFromCharacter(name, count);
        } else if (type === 'xp') {
          await removeXPFromCharacter(count);
        }
        
        // Reset form
        document.getElementById('addForm').reset();
        updateSuggestionsList(document.getElementById('type').value);
      } catch (error) {
        console.error('Error removing item:', error);
        alert('Failed to remove item. Please try again.');
      }
    });
    async function loadData() {
      // Removed due to CORS issues and not being used
    }
    // setInterval(loadData, 5000);
    // loadData();
  </script>
  <script>
    // Supabase character sheet integration
    let currentUsername = null;
    let currentCharacter = null;
    // Expect username to be passed via localStorage from index.html
    window.addEventListener('DOMContentLoaded', async function() {
      // Try to get username from query string first
      function getQueryParam(name) {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get(name);
      }
      let username = getQueryParam('username');
      if (!username) {
        username = localStorage.getItem('dnd_username');
      } else {
        localStorage.setItem('dnd_username', username);
      }
      if (username) {
        currentUsername = username;
        const character = await fetchCharacter(username);
        if (character) {
          currentCharacter = character;
          renderCharacterSheet(character);
        }
      } else {
        window.location.href = 'index.html';
      }
    });

    function renderCharacterSheet(character) {
  // Free stat points
  freeStatPoints = character.free_stat_points ?? 0;
  let statPointDiv = document.getElementById('free-stat-points');
  if (!statPointDiv) {
    statPointDiv = document.createElement('div');
    statPointDiv.id = 'free-stat-points';
    statPointDiv.style = 'margin-top:10px;color:#faa61a;font-size:1em;';
    document.querySelector('.profile').appendChild(statPointDiv);
  }
  statPointDiv.textContent = `Free stat points to allocate: ${freeStatPoints}`;
  // Avatar display
  const avatarImg = document.getElementById('avatar-img');
  if (avatarImg) {
    if (character.avatar_url) {
      avatarImg.src = character.avatar_url;
    } else {
      avatarImg.src = 'avatar.png';
    }
  }
  document.getElementById('char-name').textContent = character.name || character.username || '';
  document.getElementById('char-class').textContent = `Level ${character.level ?? ''} ${character.class ?? ''}`;
  // Summary
  let summary = '';
  if (character.race) summary += `<b>Race:</b> ${character.race} `;
  if (character.class) summary += `<b>Class:</b> ${character.class} `;
  if (character.background) summary += `<b>Background:</b> ${character.background}`;
  document.getElementById('char-summary').innerHTML = summary;
  // Bio at bottom of profile
  // Editable bio (show textarea only when "Edit Bio" clicked)
  const bioEdit = document.getElementById('bio-edit');
  const saveBtn = document.getElementById('save-bio-btn');
  if (bioEdit) bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';

  const charBioDiv = document.getElementById('char-bio');
  const storyBioDiv = document.getElementById('story-bio');
  // do not show the separate story-bio container
  if (storyBioDiv) storyBioDiv.style.display = 'none';

  // helper to escape HTML
  function escHtml(s) {
    return (s || '').toString()
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }

  const mainBioText = character.bio && character.bio.trim() ? character.bio : 'The tale of this adventurer is yet to be written...';
  const storyBioText = character.story_bio && character.story_bio.trim() ? character.story_bio : '';

  // Merge story bio into the same container (do not show separately)
  if (storyBioText) {
    charBioDiv.innerHTML = escHtml(mainBioText).replace(/\n/g, '<br>') +
      `<div style="margin-top:12px;color:#faa61a;white-space:pre-line;"><strong>Story Bio (GM):</strong><br>${escHtml(storyBioText).replace(/\n/g, '<br>')}</div>`;
  } else {
    charBioDiv.innerHTML = escHtml(mainBioText).replace(/\n/g, '<br>');
  }

  // Hide the edit panel by default and show an "Edit Bio" button
  if (bioEdit && saveBtn) {
    const bioContainer = bioEdit.parentElement; // the div that contains label, textarea, and save button
    // create Edit button if not present
    let editBtn = document.getElementById('edit-bio-btn');
    if (!editBtn) {
      editBtn = document.createElement('button');
      editBtn.id = 'edit-bio-btn';
      editBtn.textContent = 'Edit Bio';
      editBtn.style = 'margin-top:10px;background:#7289da;color:#fff;border:none;border-radius:6px;padding:6px 16px;cursor:pointer;';
    }
    // create Cancel button to appear while editing
    let cancelBtn = document.getElementById('cancel-bio-btn');
    if (!cancelBtn) {
      cancelBtn = document.createElement('button');
      cancelBtn.id = 'cancel-bio-btn';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.style = 'margin-left:8px;background:#777;color:#fff;border:none;border-radius:6px;padding:6px 12px;cursor:pointer;display:none;';
    }

    // ensure the edit button sits before the bio container
    if (bioContainer && bioContainer.parentElement) {
      if (!editBtn.parentElement) bioContainer.parentElement.insertBefore(editBtn, bioContainer);
      if (!cancelBtn.parentElement) bioContainer.appendChild(cancelBtn);
      // hide the bio container (label + textarea + save) by default
      bioContainer.style.display = 'none';
      // show edit button
      editBtn.style.display = 'inline-block';
    }

    // open editor when clicking Edit
    editBtn.addEventListener('click', function() {
      // populate current text and show
      bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';
      bioContainer.style.display = 'block';
      editBtn.style.display = 'none';
      cancelBtn.style.display = 'inline-block';
      bioEdit.focus();
    });

    // cancel editing
    cancelBtn.addEventListener('click', function() {
      bioContainer.style.display = 'none';
      cancelBtn.style.display = 'none';
      editBtn.style.display = 'inline-block';
      // revert textarea to current character bio
      bioEdit.value = character.bio && character.bio.trim() ? character.bio : '';
    });

    // After saving, hide the editor panel. Add only once.
    if (!saveBtn.dataset.hideAfterSave) {
      saveBtn.dataset.hideAfterSave = '1';
      saveBtn.addEventListener('click', function() {
        // small delay to allow the existing save handler to complete updates
        setTimeout(() => {
          bioContainer.style.display = 'none';
          cancelBtn.style.display = 'none';
          editBtn.style.display = 'inline-block';
          // update displayed bio from currentCharacter if available
          const newText = (currentCharacter && currentCharacter.bio) ? currentCharacter.bio : mainBioText;
          charBioDiv.innerHTML = escHtml(newText).replace(/\n/g, '<br>') +
            (storyBioText ? `<div style="margin-top:12px;color:#faa61a;white-space:pre-line;"><strong>Story Bio (GM):</strong><br>${escHtml(storyBioText).replace(/\n/g, '<br>')}</div>` : '');
        }, 250);
      });
    }
  }

      // Bonus logic
      const raceInfo = {
        "Human": { bonus: { strength: 1, dexterity: 1, constitution: 1 } },
        "Elf": { bonus: { dexterity: 2, intelligence: 1 } },
        "Dwarf": { bonus: { constitution: 2, strength: 1 } },
        "Halfling": { bonus: { dexterity: 2, charisma: 1 } },
        "Dragonborn": { bonus: { strength: 2, charisma: 1 } },
        "Gnome": { bonus: { intelligence: 2, constitution: 1 } },
        "Half-Elf": { bonus: { charisma: 2, dexterity: 1 } },
        "Half-Orc": { bonus: { strength: 2, constitution: 1 } },
        "Tiefling": { bonus: { charisma: 2, intelligence: 1 } }
      };
      const classInfo = {
        "Fighter": { bonus: { strength: 2 }, skill: "Athletics" },
        "Rogue": { bonus: { dexterity: 2 }, skill: "Stealth" },
        "Wizard": { bonus: { intelligence: 2 }, skill: "Arcana" },
        "Cleric": { bonus: { wisdom: 2 }, skill: "Religion" },
        "Barbarian": { bonus: { strength: 1, constitution: 1 }, skill: "Athletics" },
        "Bard": { bonus: { charisma: 2 }, skill: "Performance" },
        "Druid": { bonus: { wisdom: 1, constitution: 1 }, skill: "Nature" },
        "Monk": { bonus: { dexterity: 1, wisdom: 1 }, skill: "Acrobatics" },
        "Paladin": { bonus: { strength: 1, charisma: 1 }, skill: "Persuasion" },
        "Ranger": { bonus: { dexterity: 1, wisdom: 1 }, skill: "Survival" },
        "Sorcerer": { bonus: { charisma: 1, constitution: 1 }, skill: "Arcana" },
        "Warlock": { bonus: { charisma: 1, intelligence: 1 }, skill: "Intimidation" }
      };
      const backgroundInfo = {
        "Acolyte": { skills: ["Insight", "Religion"], bonus: { wisdom: 1 } },
        "Charlatan": { skills: ["Deception", "Sleight of Hand"], bonus: { charisma: 1 } },
        "Criminal": { skills: ["Deception", "Stealth"], bonus: { dexterity: 1 } },
        "Entertainer": { skills: ["Acrobatics", "Performance"], bonus: { charisma: 1 } },
        "Folk Hero": { skills: ["Animal Handling", "Survival"], bonus: { constitution: 1 } },
        "Guild Artisan": { skills: ["Insight", "Persuasion"], bonus: { intelligence: 1 } },
        "Hermit": { skills: ["Medicine", "Religion"], bonus: { wisdom: 1 } },
        "Noble": { skills: ["History", "Persuasion"], bonus: { charisma: 1 } },
        "Outlander": { skills: ["Athletics", "Survival"], bonus: { constitution: 1 } },
        "Sage": { skills: ["Arcana", "History"], bonus: { intelligence: 1 } },
        "Sailor": { skills: ["Athletics", "Perception"], bonus: { strength: 1 } },
        "Soldier": { skills: ["Athletics", "Intimidation"], bonus: { strength: 1 } },
        "Urchin": { skills: ["Sleight of Hand", "Stealth"], bonus: { dexterity: 1 } }
      };

      // Stats
      const statsTable = document.getElementById('stats-table');
      statsTable.innerHTML = '<tr><th style="width:30%;">Stat</th><th style="width:20%;">Total</th><th style="width:50%;"></th></tr>';
      
      // Level and XP display
      const levelRow = document.createElement('tr');
      const levelTh = document.createElement('th');
      levelTh.textContent = 'Level';
      const levelTd = document.createElement('td');
      levelTd.textContent = character.level ?? 1;
      const levelBreakdown = document.createElement('td');
      levelBreakdown.textContent = '';
      levelRow.appendChild(levelTh);
      levelRow.appendChild(levelTd);
      levelRow.appendChild(levelBreakdown);
      statsTable.appendChild(levelRow);
      
      const xpRow = document.createElement('tr');
      const xpTh = document.createElement('th');
      xpTh.textContent = 'XP';
      const xpTd = document.createElement('td');
      xpTd.textContent = character.xp ?? 0;
      const xpBreakdown = document.createElement('td');
      const currentLevel = character.level ?? 1;
      const xpForNextLevel = 100 * (currentLevel + 1);
      const currentXP = character.xp ?? 0;
      xpBreakdown.textContent = `[${xpForNextLevel - currentXP} needed for level ${currentLevel + 1}]`;
      xpRow.appendChild(xpTh);
      xpRow.appendChild(xpTd);
      xpRow.appendChild(xpBreakdown);
      statsTable.appendChild(xpRow);
      
      const statKeys = ['strength','dexterity','constitution','intelligence','wisdom','charisma'];
      statKeys.forEach(key => {
        let base = character[key] ?? 0;
        let bonus = 0;
        let breakdown = [];
        // Race bonus
        if (character.race && raceInfo[character.race] && raceInfo[character.race].bonus && raceInfo[character.race].bonus[key]) {
          bonus += raceInfo[character.race].bonus[key];
          breakdown.push(`Race +${raceInfo[character.race].bonus[key]}`);
        }
        // Class bonus
        if (character.class && classInfo[character.class] && classInfo[character.class].bonus && classInfo[character.class].bonus[key]) {
          bonus += classInfo[character.class].bonus[key];
          breakdown.push(`Class +${classInfo[character.class].bonus[key]}`);
        }
        // Background bonus
        if (character.background && backgroundInfo[character.background] && backgroundInfo[character.background].bonus && backgroundInfo[character.background].bonus[key]) {
          bonus += backgroundInfo[character.background].bonus[key];
          breakdown.push(`Background +${backgroundInfo[character.background].bonus[key]}`);
        }
        // Total value
        const total = base + bonus;
        const row = document.createElement('tr');
        const th = document.createElement('th');
        th.textContent = key.charAt(0).toUpperCase() + key.slice(1);
        const tdTotal = document.createElement('td');
        tdTotal.textContent = total;
        const tdBreakdown = document.createElement('td');
        tdBreakdown.textContent = breakdown.length ? `[${breakdown.join(', ')}]` : '';
        row.appendChild(th);
        row.appendChild(tdTotal);
        row.appendChild(tdBreakdown);
        statsTable.appendChild(row);
      });
      // Weapons, Armor, Items tables
      const weaponsTable = document.getElementById('weapons-table');
      const armorTable = document.getElementById('armor-table');
      const itemsTable = document.getElementById('items-table');
      weaponsTable.innerHTML = '<tr><th style="width:40%;">Name</th><th style="width:25%;">Type</th><th style="width:20%;">Damage</th><th style="width:15%;">Quantity</th></tr>';
      armorTable.innerHTML = '<tr><th style="width:40%;">Name</th><th style="width:25%;">Type</th><th style="width:20%;">AC</th><th style="width:15%;">Quantity</th></tr>';
      itemsTable.innerHTML = '<tr><th style="width:70%;">Name</th><th style="width:30%;">Quantity</th></tr>';
      // Items
      (Array.isArray(character.items) ? character.items : []).forEach(item => {
        if ((item.count ?? 0) > 0) {
          const row = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = item.name;
          nameCell.setAttribute('data-type', 'items');
          nameCell.setAttribute('data-name', item.name);
          const qtyCell = document.createElement('td');
          qtyCell.textContent = item.count ?? 0;
          row.appendChild(nameCell);
          row.appendChild(qtyCell);
          itemsTable.appendChild(row);
        }
      });
      // Equipment split
      (Array.isArray(character.equipment) ? character.equipment : []).forEach(eq => {
        if ((eq.count ?? 0) > 0 && dndData) {
          const eqData = (dndData.equipment || []).find(e => e.name === eq.name);
          if (eqData && eqData.type && eqData.type.toLowerCase().includes('weapon')) {
            // Weapon
            const row = document.createElement('tr');
            const nameCell = document.createElement('td');
            nameCell.textContent = eq.name;
            nameCell.setAttribute('data-type', 'equipment');
            nameCell.setAttribute('data-name', eq.name);
            const typeCell = document.createElement('td');
            typeCell.textContent = eqData.type;
            const dmgCell = document.createElement('td');
            dmgCell.textContent = eqData.damage || '';
            const qtyCell = document.createElement('td');
            qtyCell.textContent = eq.count ?? 0;
            row.appendChild(nameCell);
            row.appendChild(typeCell);
            row.appendChild(dmgCell);
            row.appendChild(qtyCell);
            weaponsTable.appendChild(row);
          } else if (eqData && eqData.type && eqData.type.toLowerCase().includes('armor')) {
            // Armor
            const row = document.createElement('tr');
            const nameCell = document.createElement('td');
            nameCell.textContent = eq.name;
            nameCell.setAttribute('data-type', 'equipment');
            nameCell.setAttribute('data-name', eq.name);
            const typeCell = document.createElement('td');
            typeCell.textContent = eqData.type;
            const acCell = document.createElement('td');
            acCell.textContent = eqData.ac || '';
            const qtyCell = document.createElement('td');
            qtyCell.textContent = eq.count ?? 0;
            row.appendChild(nameCell);
            row.appendChild(typeCell);
            row.appendChild(acCell);
            row.appendChild(qtyCell);
            armorTable.appendChild(row);
          } else {
            // If not weapon/armor, treat as item
            const row = document.createElement('tr');
            const nameCell = document.createElement('td');
            nameCell.textContent = eq.name;
            nameCell.setAttribute('data-type', 'equipment');
            nameCell.setAttribute('data-name', eq.name);
            const qtyCell = document.createElement('td');
            qtyCell.textContent = eq.count ?? 0;
            row.appendChild(nameCell);
            row.appendChild(qtyCell);
            itemsTable.appendChild(row);
          }
        }
      });
      // Spells
      const spellsTable = document.getElementById('spells-table');
      spellsTable.innerHTML = '<tr><th style="width:70%;">Name</th><th style="width:30%;">Level</th></tr>';
      (Array.isArray(character.spells) ? character.spells : []).forEach(spell => {
        if ((spell.count ?? 0) > 0) {
          const row = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = spell.name;
          nameCell.setAttribute('data-type', 'spells');
          nameCell.setAttribute('data-name', spell.name);
          const lvlCell = document.createElement('td');
          // Show spell level if available
          let spellData = (dndData && dndData.spells) ? dndData.spells.find(sp => sp.name === spell.name) : null;
          lvlCell.textContent = spellData && spellData.level ? spellData.level : (spell.level ?? '');
          row.appendChild(nameCell);
          row.appendChild(lvlCell);
          spellsTable.appendChild(row);
        }
      });
      // Skills
      const skillsTable = document.getElementById('skills-table');
      skillsTable.innerHTML = '<tr><th style="width:100%;">Name</th></tr>';
      (Array.isArray(character.skills) ? character.skills : []).forEach(skill => {
        let bonus = 0;
        let sources = [];
        // Class bonus
        if (character.class && classInfo[character.class] && classInfo[character.class].skill === skill.name) {
          bonus += 2;
          sources.push('Class +2');
        }
        // Background bonus
        if (character.background && backgroundInfo[character.background] && backgroundInfo[character.background].skills && backgroundInfo[character.background].skills.includes(skill.name)) {
          bonus += 2;
          sources.push('Background +2');
        }
        let display = skill.name;
        if (bonus > 0) {
          display += ` (+${bonus} [${sources.join(', ')}])`;
        }
        if ((skill.count ?? 0) > 0 || bonus > 0) {
          const row = document.createElement('tr');
          const nameCell = document.createElement('td');
          nameCell.textContent = display;
          nameCell.setAttribute('data-type', 'skills');
          nameCell.setAttribute('data-name', skill.name);
          row.appendChild(nameCell);
          skillsTable.appendChild(row);
        }
      });
      attachTooltipListeners();
    // Tooltip logic
    function getTooltipContent(type, name) {
      if (!dndData) return '';
      let entry = null;
      if (type === 'items') entry = (dndData.items || []).find(i => i.name === name);
      else if (type === 'equipment') entry = (dndData.equipment || []).find(e => e.name === name);
      else if (type === 'skills') entry = (dndData.skills || []).find(s => s.name === name);
      else if (type === 'spells') entry = (dndData.spells || []).find(sp => sp.name === name);
      if (!entry) return '';
      let html = `<b>${entry.name}</b><br>`;
      if (type === 'items' || type === 'equipment') {
        if (entry.type) html += `<i>Type:</i> ${entry.type}<br>`;
        if (entry.damage) html += `<i>Damage:</i> ${entry.damage}<br>`;
        if (entry.ac) html += `<i>AC:</i> ${entry.ac}<br>`;
        if (entry.ac_bonus) html += `<i>AC Bonus:</i> ${entry.ac_bonus}<br>`;
        if (entry.dex_bonus) html += `<i>Dex Bonus:</i> Yes<br>`;
        if (entry.strength_req) html += `<i>Strength Req:</i> ${entry.strength_req}<br>`;
        if (entry.stealth_disadvantage) html += `<i>Stealth Disadvantage:</i> Yes<br>`;
        if (entry.effect) html += `<i>Effect:</i> ${entry.effect}<br>`;
        if (entry.properties) html += `<i>Properties:</i> ${entry.properties.join(', ')}<br>`;
      }
      if (type === 'skills') {
        if (entry.ability) html += `<i>Ability:</i> ${entry.ability}<br>`;
      }
      if (type === 'spells') {
        if (entry.level) html += `<i>Level:</i> ${entry.level}<br>`;
        if (entry.school) html += `<i>School:</i> ${entry.school}<br>`;
        if (entry.description) html += `<i>Description:</i> ${entry.description}<br>`;
      }
      return html;
    }

    function showTooltip(e, type, name) {
      const tooltip = document.getElementById('tooltip');
      tooltip.innerHTML = getTooltipContent(type, name);
      tooltip.style.display = 'block';
      const rect = e.target.getBoundingClientRect();
      tooltip.style.left = `${rect.right + 10 + window.scrollX}px`;
      tooltip.style.top = `${rect.top + window.scrollY}px`;
    }

    function hideTooltip() {
      const tooltip = document.getElementById('tooltip');
      tooltip.style.display = 'none';
    }

    // Attach tooltip listeners after rendering character sheet
    function attachTooltipListeners() {
      ['weapons-table', 'armor-table', 'items-table', 'skills-table', 'spells-table'].forEach(tableId => {
        const table = document.getElementById(tableId);
        if (!table) return;
        table.querySelectorAll('td[data-type]').forEach(td => {
          td.addEventListener('mouseenter', function(e) {
            const type = td.getAttribute('data-type');
            const name = td.getAttribute('data-name');
            showTooltip(e, type, name);
          });
          td.addEventListener('mouseleave', hideTooltip);
        });
      });
    }
    }

    // Example: Add item and update DB
    async function addItemToCharacter(itemName, count) {
      if (!currentCharacter || !currentUsername) return;
      let items = currentCharacter.items || [];
      const idx = items.findIndex(i => i.name === itemName);
      if (idx > -1) items[idx].count += count;
      else items.push({ name: itemName, count });
      await updateCharacter(currentUsername, { items });
      currentCharacter.items = items;
      renderCharacterSheet(currentCharacter);
    }

    // Add equipment and update DB
    async function addEquipmentToCharacter(equipmentName, count) {
      if (!currentCharacter || !currentUsername) return;
      let equipment = currentCharacter.equipment || [];
      const idx = equipment.findIndex(e => e.name === equipmentName);
      if (idx > -1) equipment[idx].count += count;
      else equipment.push({ name: equipmentName, count });
      await updateCharacter(currentUsername, { equipment });
      currentCharacter.equipment = equipment;
      renderCharacterSheet(currentCharacter);
    }

    // Add skill and update DB
    async function addSkillToCharacter(skillName, count) {
      if (!currentCharacter || !currentUsername) return;
      let skills = currentCharacter.skills || [];
      const idx = skills.findIndex(s => s.name === skillName);
      if (idx > -1) skills[idx].count += count;
      else skills.push({ name: skillName, count });
      await updateCharacter(currentUsername, { skills });
      currentCharacter.skills = skills;
      renderCharacterSheet(currentCharacter);
    }

    // Add spell and update DB
    async function addSpellToCharacter(spellName, count) {
      if (!currentCharacter || !currentUsername) return;
      let spells = currentCharacter.spells || [];
      const idx = spells.findIndex(sp => sp.name === spellName);
      if (idx > -1) spells[idx].count += count;
      else spells.push({ name: spellName, count });
      await updateCharacter(currentUsername, { spells });
      currentCharacter.spells = spells;
      renderCharacterSheet(currentCharacter);
    }

    // Remove item and update DB
    async function removeItemFromCharacter(itemName, count) {
      if (!currentCharacter || !currentUsername) return;
      let items = currentCharacter.items || [];
      const idx = items.findIndex(i => i.name === itemName);
      if (idx > -1) {
        items[idx].count = Math.max(0, items[idx].count - count);
      }
      await updateCharacter(currentUsername, { items });
      currentCharacter.items = items;
      renderCharacterSheet(currentCharacter);
    }

    // Remove equipment and update DB
    async function removeEquipmentFromCharacter(equipmentName, count) {
      if (!currentCharacter || !currentUsername) return;
      let equipment = currentCharacter.equipment || [];
      const idx = equipment.findIndex(e => e.name === equipmentName);
      if (idx > -1) {
        equipment[idx].count = Math.max(0, equipment[idx].count - count);
      }
      await updateCharacter(currentUsername, { equipment });
      currentCharacter.equipment = equipment;
      renderCharacterSheet(currentCharacter);
    }

    // Remove skill and update DB
    async function removeSkillFromCharacter(skillName, count) {
      if (!currentCharacter || !currentUsername) return;
      let skills = currentCharacter.skills || [];
      const idx = skills.findIndex(s => s.name === skillName);
      if (idx > -1) {
        skills[idx].count = Math.max(0, skills[idx].count - count);
      }
      await updateCharacter(currentUsername, { skills });
      currentCharacter.skills = skills;
      renderCharacterSheet(currentCharacter);
    }

    // Remove spell and update DB
    async function removeSpellFromCharacter(spellName, count) {
      if (!currentCharacter || !currentUsername) return;
      let spells = currentCharacter.spells || [];
      const idx = spells.findIndex(sp => sp.name === spellName);
      if (idx > -1) {
        spells[idx].count = Math.max(0, spells[idx].count - count);
      }
      await updateCharacter(currentUsername, { spells });
      currentCharacter.spells = spells;
      renderCharacterSheet(currentCharacter);
    }

    // Add XP and handle level progression
    async function addXPToCharacter(xpAmount) {
      if (!currentCharacter || !currentUsername) return;
      let currentXP = currentCharacter.xp || 0;
      let currentLevel = currentCharacter.level || 1;
      let statPoints = currentCharacter.free_stat_points || 0;
      let leveledUp = false;
      // Add XP
      currentXP += xpAmount;
      // Check for level ups (100 * (currentLevel+1) XP needed for each level)
      while (currentXP >= (100 * (currentLevel + 1))) {
        currentXP -= (100 * (currentLevel + 1));
        currentLevel++;
        statPoints += 2;
        leveledUp = true;
      }
      const res = await updateCharacter(currentUsername, { xp: currentXP, level: currentLevel, free_stat_points: statPoints });
      if (!res) {
        // updateCharacter will have already alerted; stop further UI updates
        console.warn('addXPToCharacter: updateCharacter returned null');
        return;
      }
      // res should be the updated character row
      currentCharacter = res;
      renderCharacterSheet(currentCharacter);
      if (leveledUp) {
        alert(`Congratulations! You've reached level ${currentLevel} and earned ${statPoints} free stat points!`);
      }
    }

    // Remove XP (can cause level down if XP goes negative)
    async function removeXPFromCharacter(xpAmount) {
      if (!currentCharacter || !currentUsername) return;
      let currentXP = currentCharacter.xp || 0;
      let currentLevel = currentCharacter.level || 1;
      let statPoints = currentCharacter.free_stat_points || 0;
      // Remove XP
      currentXP = Math.max(0, currentXP - xpAmount);
      // Check for level downs if we go below 0 XP for current level
      while (currentLevel > 1 && currentXP < 0) {
        currentLevel--;
        currentXP += (100 * (currentLevel + 1));
        statPoints = Math.max(0, statPoints - 2);
      }
      // Make sure XP doesn't go negative
      currentXP = Math.max(0, currentXP);
      const res = await updateCharacter(currentUsername, { xp: currentXP, level: currentLevel, free_stat_points: statPoints });
      if (!res) {
        console.warn('removeXPFromCharacter: updateCharacter returned null');
        return;
      }
      currentCharacter = res;
      renderCharacterSheet(currentCharacter);
    }
  </script>
</body>
</html>